<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>光影迷宫 - 核心玩法Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .game-container {
            background: rgba(0, 0, 0, 0.9);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .game-header {
            color: #fff;
            text-align: center;
            margin-bottom: 20px;
        }

        .game-header h1 {
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            color: #fff;
            font-size: 14px;
        }

        .info-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 5px;
        }

        #gameCanvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            display: block;
            background: #000;
        }

        .controls {
            margin-top: 20px;
            text-align: center;
        }

        .control-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 10px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .control-btn.solve {
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
        }

        .control-btn.solve:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .control-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .instructions {
            color: #fff;
            text-align: center;
            margin-top: 15px;
            font-size: 14px;
            line-height: 1.5;
            max-width: 600px;
        }

        .success-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 18px;
            display: none;
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .level-indicator {
            color: #ffd700;
            font-weight: bold;
        }

        .energy-bar {
            width: 200px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .energy-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffed4e);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1>🌟 光影迷宫 🌟</h1>
            <p>移动光源改变影子，搭建通路到达目标</p>
        </div>

        <div class="game-info">
            <div class="info-item">关卡: <span class="level-indicator" id="currentLevel">1</span>/3</div>
            <div class="info-item">
                能量:
                <div class="energy-bar" style="display: inline-block; vertical-align: middle;">
                    <div class="energy-fill" id="energyFill" style="width: 100%;"></div>
                </div>
            </div>
            <div class="info-item">步数: <span id="moveCount">0</span></div>
        </div>

        <canvas id="gameCanvas" width="800" height="500"></canvas>

        <div class="controls">
            <button class="control-btn" onclick="game.resetLevel()">重置关卡</button>
            <button class="control-btn" onclick="game.nextLevel()">下一关</button>
            <button class="control-btn solve" onclick="game.autoSolve()" id="solveBtn">自动求解</button>
            <button class="control-btn" onclick="game.checkAndAutoMove()">自动移动</button>
            <button class="control-btn" onclick="game.debugShadows()">调试影子</button>
            <button class="control-btn" onclick="game.toggleHelp()">帮助</button>
        </div>

        <div class="instructions">
            <p><strong>操作说明：</strong> 点击光源拖动移动 • 影子会实时变化 • 搭建影子通路到达绿色目标</p>
            <p><strong>目标：</strong> 使用最少的能量和步数完成关卡 • 收集星星获得额外奖励</p>
        </div>

        <div class="success-message" id="successMessage">
            🎉 关卡完成！🎉
        </div>
    </div>

    <script>
        class LightShadowGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.currentLevel = 0;
                this.moveCount = 0;
                this.energy = 100;
                this.maxEnergy = 100;
                this.isDragging = false;
                this.selectedLight = null;
                this.stars = [];
                this.collectedStars = 0;
                this.isAutoSolving = false;
                this.autoSolveSteps = [];
                this.autoSolveIndex = 0;
                this.isPlayerMoving = false;

                this.levels = [
                    {
                        name: "初识光影",
                        lightSources: [
                            { x: 200, y: 100, radius: 150, color: '#ffd700', id: 'light1' }
                        ],
                        obstacles: [
                            { x: 300, y: 200, width: 50, height: 200 },
                            { x: 500, y: 100, width: 50, height: 150 }
                        ],
                        target: { x: 700, y: 400, width: 60, height: 60 },
                        player: { x: 100, y: 400, width: 30, height: 30 },
                        stars: [
                            { x: 400, y: 300, collected: false },
                            { x: 600, y: 200, collected: false }
                        ]
                    },
                    {
                        name: "双重光源",
                        lightSources: [
                            { x: 150, y: 150, radius: 120, color: '#ffd700', id: 'light1' },
                            { x: 650, y: 150, radius: 120, color: '#87ceeb', id: 'light2' }
                        ],
                        obstacles: [
                            { x: 250, y: 200, width: 40, height: 150 },
                            { x: 450, y: 100, width: 40, height: 200 },
                            { x: 350, y: 350, width: 200, height: 40 }
                        ],
                        target: { x: 700, y: 450, width: 60, height: 60 },
                        player: { x: 100, y: 450, width: 30, height: 30 },
                        stars: [
                            { x: 400, y: 250, collected: false },
                            { x: 550, y: 400, collected: false },
                            { x: 250, y: 350, collected: false }
                        ]
                    },
                    {
                        name: "光影迷宫",
                        lightSources: [
                            { x: 100, y: 100, radius: 100, color: '#ffd700', id: 'light1' },
                            { x: 400, y: 250, radius: 80, color: '#ff69b4', id: 'light2' },
                            { x: 700, y: 100, radius: 120, color: '#87ceeb', id: 'light3' }
                        ],
                        obstacles: [
                            { x: 200, y: 150, width: 30, height: 100 },
                            { x: 300, y: 50, width: 30, height: 150 },
                            { x: 400, y: 200, width: 30, height: 200 },
                            { x: 500, y: 100, width: 30, height: 150 },
                            { x: 600, y: 250, width: 30, height: 100 },
                            { x: 200, y: 350, width: 400, height: 30 }
                        ],
                        target: { x: 750, y: 450, width: 60, height: 60 },
                        player: { x: 50, y: 450, width: 30, height: 30 },
                        stars: [
                            { x: 250, y: 250, collected: false },
                            { x: 550, y: 150, collected: false },
                            { x: 400, y: 400, collected: false },
                            { x: 650, y: 350, collected: false }
                        ]
                    }
                ];

                this.init();
            }

            init() {
                this.loadLevel(0);
                this.setupEventListeners();
                this.gameLoop();
            }

            loadLevel(levelIndex) {
                if (levelIndex >= this.levels.length) {
                    this.showMessage("🎊 恭喜通关所有关卡！🎊");
                    return;
                }

                this.currentLevel = levelIndex;
                const level = this.levels[levelIndex];

                // 深拷贝关卡数据
                this.lightSources = JSON.parse(JSON.stringify(level.lightSources));
                this.obstacles = JSON.parse(JSON.stringify(level.obstacles));
                this.target = JSON.parse(JSON.stringify(level.target));
                this.player = JSON.parse(JSON.stringify(level.player));
                this.stars = JSON.parse(JSON.stringify(level.stars));

                this.moveCount = 0;
                this.energy = this.maxEnergy;
                this.collectedStars = 0;
                this.updateUI();
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
            }

            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // 检查是否点击了光源
                for (let light of this.lightSources) {
                    const dist = Math.sqrt((x - light.x) ** 2 + (y - light.y) ** 2);
                    if (dist < 20) {
                        this.isDragging = true;
                        this.selectedLight = light;
                        break;
                    }
                }
            }

            handleMouseMove(e) {
                if (!this.isDragging || !this.selectedLight) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                this.selectedLight.x = x;
                this.selectedLight.y = y;
            }

            handleMouseUp(e) {
                if (this.isDragging) {
                    this.moveCount++;
                    this.energy = Math.max(0, this.energy - 5);
                    this.updateUI();
                }
                this.isDragging = false;
                this.selectedLight = null;
            }

            handleTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                this.canvas.dispatchEvent(mouseEvent);
            }

            handleTouchMove(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                this.canvas.dispatchEvent(mouseEvent);
            }

            handleTouchEnd(e) {
                e.preventDefault();
                const mouseEvent = new MouseEvent('mouseup', {});
                this.canvas.dispatchEvent(mouseEvent);
            }

            calculateShadows() {
                const shadows = [];

                for (let light of this.lightSources) {
                    for (let obstacle of this.obstacles) {
                        // 计算障碍物的影子
                        const shadow = this.calculateObstacleShadow(light, obstacle);
                        if (shadow) {
                            shadows.push(shadow);
                        }
                    }
                }

                return shadows;
            }

            calculateObstacleShadow(light, obstacle) {
                const corners = [
                    { x: obstacle.x, y: obstacle.y },
                    { x: obstacle.x + obstacle.width, y: obstacle.y },
                    { x: obstacle.x + obstacle.width, y: obstacle.y + obstacle.height },
                    { x: obstacle.x, y: obstacle.y + obstacle.height }
                ];

                // 计算哪些角点在光照范围内
                const litCorners = [];
                const shadowCorners = [];

                for (let corner of corners) {
                    const dx = corner.x - light.x;
                    const dy = corner.y - light.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < light.radius) {
                        litCorners.push(corner);
                    } else {
                        shadowCorners.push(corner);
                    }
                }

                // 如果所有角点都被照亮或都在阴影中，不产生影子
                if (litCorners.length === 0 || litCorners.length === 4) {
                    return null;
                }

                // 创建影子多边形
                const shadowPoints = [];

                // 添加被照亮的角点
                for (let corner of litCorners) {
                    shadowPoints.push(corner);
                }

                // 为每个被照亮的角点计算延伸点
                for (let corner of litCorners) {
                    const dx = corner.x - light.x;
                    const dy = corner.y - light.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 0) {
                        const extendX = (dx / distance) * 500;
                        const extendY = (dy / distance) * 500;
                        shadowPoints.push({
                            x: corner.x + extendX,
                            y: corner.y + extendY
                        });
                    }
                }

                // 添加未被照亮的角点
                for (let corner of shadowCorners) {
                    shadowPoints.push(corner);
                }

                return {
                    points: shadowPoints,
                    color: 'rgba(0, 0, 0, 0.8)'
                };
            }

            checkWinCondition() {
                // 检查玩家是否在目标区域
                if (this.player.x < this.target.x + this.target.width &&
                    this.player.x + this.player.width > this.target.x &&
                    this.player.y < this.target.y + this.target.height &&
                    this.player.y + this.player.height > this.target.y) {
                    this.showMessage("🎉 关卡完成！🎉");
                    setTimeout(() => {
                        this.hideMessage();
                        // 自动进入下一关
                        setTimeout(() => {
                            this.nextLevel();
                        }, 1000);
                    }, 2000);
                    return true;
                }
                return false;
            }

            // 新增：检查是否有路径并自动移动
            checkAndAutoMove() {
                if (this.hasPathToTarget()) {
                    this.animatePlayerToTarget(() => {
                        // 移动完成后，检查胜利条件
                        this.checkWinCondition();
                    });
                    return true;
                }
                return false;
            }

            checkStarCollection() {
                for (let star of this.stars) {
                    if (!star.collected &&
                        this.player.x < star.x + 20 &&
                        this.player.x + this.player.width > star.x - 10 &&
                        this.player.y < star.y + 20 &&
                        this.player.y + this.player.height > star.y - 10) {
                        star.collected = true;
                        this.collectedStars++;
                        this.energy = Math.min(this.maxEnergy, this.energy + 10);
                        this.updateUI();
                    }
                }
            }

            updateUI() {
                document.getElementById('currentLevel').textContent = this.currentLevel + 1;
                document.getElementById('moveCount').textContent = this.moveCount;
                document.getElementById('energyFill').style.width = `${(this.energy / this.maxEnergy) * 100}%`;
            }

            showMessage(text) {
                const messageEl = document.getElementById('successMessage');
                messageEl.textContent = text;
                messageEl.style.display = 'block';
            }

            hideMessage() {
                document.getElementById('successMessage').style.display = 'none';
            }

            resetLevel() {
                this.loadLevel(this.currentLevel);
            }

            nextLevel() {
                this.loadLevel(this.currentLevel + 1);
            }

            toggleHelp() {
                alert("游戏目标：移动光源改变影子位置，搭建影子通路让角色到达绿色目标区域。\n\n操作：点击并拖动光源来移动位置。\n提示：收集星星可以恢复能量！\n\n自动求解：点击'自动求解'按钮，AI会自动帮你完成关卡！");
            }

            autoSolve() {
                if (this.isAutoSolving) {
                    this.stopAutoSolve();
                    return;
                }

                this.isAutoSolving = true;
                this.autoSolveIndex = 0;
                this.autoSolveSteps = this.calculateAutoSolveSteps();

                const solveBtn = document.getElementById('solveBtn');
                solveBtn.textContent = '停止求解';
                solveBtn.style.background = 'linear-gradient(45deg, #666, #888)';

                this.showMessage("🤖 AI正在思考解决方案...");
                setTimeout(() => {
                    this.hideMessage();
                    this.executeAutoSolve();
                }, 1500);
            }

            stopAutoSolve() {
                this.isAutoSolving = false;
                const solveBtn = document.getElementById('solveBtn');
                solveBtn.textContent = '自动求解';
                solveBtn.style.background = 'linear-gradient(45deg, #ff6b6b, #ff8e53)';
            }

            calculateAutoSolveSteps() {
                const steps = [];
                const level = this.levels[this.currentLevel];

                // 根据不同关卡预设解决方案
                switch (this.currentLevel) {
                    case 0:
                        // 第一关：移动光源到正确位置，让影子连接玩家和目标
                        steps.push(
                            { lightIndex: 0, x: 400, y: 150, delay: 1200 }
                        );
                        break;
                    case 1:
                        // 第二关：调整两个光源，搭建完整的影子通路
                        steps.push(
                            { lightIndex: 0, x: 200, y: 300, delay: 1000 },
                            { lightIndex: 1, x: 600, y: 300, delay: 1200 }
                        );
                        break;
                    case 2:
                        // 第三关：协调三个光源，创建复杂的影子路径
                        steps.push(
                            { lightIndex: 0, x: 150, y: 250, delay: 1000 },
                            { lightIndex: 1, x: 400, y: 350, delay: 1200 },
                            { lightIndex: 2, x: 700, y: 250, delay: 1000 }
                        );
                        break;
                }

                return steps;
            }

            executeAutoSolve() {
                if (!this.isAutoSolving || this.autoSolveIndex >= this.autoSolveSteps.length) {
                    // 所有光源移动完成后，检查是否有路径可以到达目标
                    if (this.hasPathToTarget()) {
                        this.animatePlayerToTarget(() => {
                            this.showMessage("🎉 AI成功完成关卡！🎉");
                            setTimeout(() => {
                                this.hideMessage();
                                this.stopAutoSolve();
                                setTimeout(() => {
                                    this.nextLevel();
                                }, 2000);
                            }, 2000);
                        });
                    } else {
                        this.showMessage("❌ AI需要调整策略...");
                        setTimeout(() => {
                            this.hideMessage();
                            this.stopAutoSolve();
                        }, 2000);
                    }
                    return;
                }

                const step = this.autoSolveSteps[this.autoSolveIndex];
                const light = this.lightSources[step.lightIndex];

                // 创建平滑移动动画
                this.animateLightMove(light, step.x, step.y, () => {
                    this.moveCount++;
                    this.energy = Math.max(0, this.energy - 5);
                    this.updateUI();

                    this.autoSolveIndex++;
                    setTimeout(() => {
                        this.executeAutoSolve();
                    }, step.delay);
                });
            }

            animateLightMove(light, targetX, targetY, callback) {
                const startX = light.x;
                const startY = light.y;
                const duration = 800; // 动画持续时间
                const startTime = Date.now();

                const animate = () => {
                    if (!this.isAutoSolving) return;

                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // 使用缓动函数让移动更自然
                    const easeProgress = this.easeInOutCubic(progress);

                    light.x = startX + (targetX - startX) * easeProgress;
                    light.y = startY + (targetY - startY) * easeProgress;

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        if (callback) callback();
                    }
                };

                animate();
            }

            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }

            hasPathToTarget() {
                // 检查玩家是否在影子内，并且影子边界接触或接近目标区域
                const shadows = this.calculateShadows();
                const playerCenter = {
                    x: this.player.x + this.player.width / 2,
                    y: this.player.y + this.player.height / 2
                };

                // 检查玩家是否在影子区域内
                let playerInShadow = false;
                let shadowNearTarget = false;

                for (let shadow of shadows) {
                    if (!shadow || shadow.points.length < 3) continue;

                    // 检查玩家是否在影子内
                    if (this.pointInPolygon(playerCenter, shadow.points)) {
                        playerInShadow = true;
                    }

                    // 检查影子是否有点接近目标区域
                    for (let point of shadow.points) {
                        const distToTarget = this.distanceToTarget(point.x, point.y);
                        if (distToTarget < 100) { // 100像素内认为接近
                            shadowNearTarget = true;
                        }
                    }
                }

                // 对于第一关的特殊处理：简化检测逻辑
                if (this.currentLevel === 0) {
                    return playerInShadow && shadowNearTarget;
                }

                // 对于其他关卡，检查影子是否提供了从玩家到目标的路径
                return playerInShadow && shadowNearTarget;
            }

            distanceToTarget(x, y) {
                const targetCenterX = this.target.x + this.target.width / 2;
                const targetCenterY = this.target.y + this.target.height / 2;
                return Math.sqrt((x - targetCenterX) ** 2 + (y - targetCenterY) ** 2);
            }

            pointInPolygon(point, polygon) {
                let inside = false;
                for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                    const xi = polygon[i].x, yi = polygon[i].y;
                    const xj = polygon[j].x, yj = polygon[j].y;

                    const intersect = ((yi > point.y) != (yj > point.y))
                        && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }

            debugShadows() {
                const shadows = this.calculateShadows();
                const playerCenter = {
                    x: this.player.x + this.player.width / 2,
                    y: this.player.y + this.player.height / 2
                };

                let debugInfo = "=== 影子调试信息 ===\n";
                debugInfo += `玩家位置: (${Math.round(playerCenter.x)}, ${Math.round(playerCenter.y)})\n`;
                debugInfo += `目标位置: (${this.target.x + this.target.width/2}, ${this.target.y + this.target.height/2})\n`;
                debugInfo += `影子数量: ${shadows.length}\n\n`;

                let playerInShadow = false;
                let shadowNearTarget = false;

                for (let i = 0; i < shadows.length; i++) {
                    const shadow = shadows[i];
                    if (!shadow || shadow.points.length < 3) continue;

                    debugInfo += `影子 ${i + 1}:\n`;
                    debugInfo += `  点数: ${shadow.points.length}\n`;
                    debugInfo += `  玩家在影子内: ${this.pointInPolygon(playerCenter, shadow.points)}\n`;

                    let minDist = Infinity;
                    for (let point of shadow.points) {
                        const distToTarget = this.distanceToTarget(point.x, point.y);
                        minDist = Math.min(minDist, distToTarget);
                    }
                    debugInfo += `  到目标最近距离: ${Math.round(minDist)}\n`;

                    if (this.pointInPolygon(playerCenter, shadow.points)) {
                        playerInShadow = true;
                    }
                    if (minDist < 100) {
                        shadowNearTarget = true;
                    }
                    debugInfo += "\n";
                }

                debugInfo += `=== 检测结果 ===\n`;
                debugInfo += `玩家在影子内: ${playerInShadow}\n`;
                debugInfo += `影子接近目标: ${shadowNearTarget}\n`;
                debugInfo += `可以通过: ${this.hasPathToTarget()}\n`;

                alert(debugInfo);
            }

            animatePlayerToTarget(callback) {
                const startX = this.player.x;
                const startY = this.player.y;
                const targetX = this.target.x + this.target.width / 2 - this.player.width / 2;
                const targetY = this.target.y + this.target.height / 2 - this.player.height / 2;
                const duration = 1500;
                const startTime = Date.now();

                this.isPlayerMoving = true;

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const easeProgress = this.easeInOutCubic(progress);

                    this.player.x = startX + (targetX - startX) * easeProgress;
                    this.player.y = startY + (targetY - startY) * easeProgress;

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.isPlayerMoving = false;
                        if (callback) callback();
                    }
                };

                animate();
            }

            draw() {
                // 清空画布
                this.ctx.fillStyle = '#0a0a0a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // 绘制网格背景
                this.drawGrid();

                // 绘制光源
                for (let light of this.lightSources) {
                    this.drawLight(light);
                }

                // 计算并绘制影子
                const shadows = this.calculateShadows();
                for (let shadow of shadows) {
                    this.drawShadow(shadow);
                }

                // 绘制障碍物
                for (let obstacle of this.obstacles) {
                    this.drawObstacle(obstacle);
                }

                // 绘制星星
                for (let star of this.stars) {
                    if (!star.collected) {
                        this.drawStar(star);
                    }
                }

                // 绘制目标
                this.drawTarget();

                // 绘制玩家
                this.drawPlayer();

                // 绘制光源位置提示（如果正在拖动或自动求解）
                if ((this.isDragging && this.selectedLight) || this.isAutoSolving) {
                    for (let light of this.lightSources) {
                        this.drawLightRadius(light);
                    }
                }
            }

            drawGrid() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                this.ctx.lineWidth = 1;

                for (let x = 0; x < this.canvas.width; x += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }

                for (let y = 0; y < this.canvas.height; y += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }

            drawLight(light) {
                // 绘制光晕
                const gradient = this.ctx.createRadialGradient(light.x, light.y, 0, light.x, light.y, light.radius);
                gradient.addColorStop(0, light.color + '40');
                gradient.addColorStop(0.5, light.color + '20');
                gradient.addColorStop(1, 'transparent');

                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // 绘制光源核心
                this.ctx.beginPath();
                this.ctx.arc(light.x, light.y, 8, 0, Math.PI * 2);
                this.ctx.fillStyle = light.color;
                this.ctx.fill();

                // 绘制光源边框
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
            }

            drawLightRadius(light) {
                // 如果正在自动求解，显示特殊的AI求解效果
                if (this.isAutoSolving) {
                    const time = Date.now() / 1000;
                    const pulseAlpha = 0.3 + Math.sin(time * 3) * 0.2;
                    this.ctx.strokeStyle = light.color + Math.floor(pulseAlpha * 255).toString(16).padStart(2, '0');
                    this.ctx.lineWidth = 3;
                } else {
                    this.ctx.strokeStyle = light.color + '60';
                    this.ctx.lineWidth = 2;
                }

                this.ctx.beginPath();
                this.ctx.arc(light.x, light.y, light.radius, 0, Math.PI * 2);
                this.ctx.setLineDash([5, 5]);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }

            drawShadow(shadow) {
                if (!shadow || shadow.points.length < 3) return;

                this.ctx.beginPath();
                this.ctx.moveTo(shadow.points[0].x, shadow.points[0].y);
                for (let i = 1; i < shadow.points.length; i++) {
                    this.ctx.lineTo(shadow.points[i].x, shadow.points[i].y);
                }
                this.ctx.closePath();

                this.ctx.fillStyle = shadow.color;
                this.ctx.fill();

                // 添加影子边缘高光效果
                this.ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
            }

            drawObstacle(obstacle) {
                // 绘制障碍物主体
                this.ctx.fillStyle = '#4a4a4a';
                this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

                // 绘制障碍物边框
                this.ctx.strokeStyle = '#666';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            }

            drawStar(star) {
                const time = Date.now() / 1000;
                const scale = 1 + Math.sin(time * 3) * 0.1;

                this.ctx.save();
                this.ctx.translate(star.x, star.y);
                this.ctx.scale(scale, scale);

                // 绘制星星
                this.ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                    const x = Math.cos(angle) * 10;
                    const y = Math.sin(angle) * 10;
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.closePath();

                this.ctx.fillStyle = '#ffd700';
                this.ctx.fill();
                this.ctx.strokeStyle = '#ffed4e';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();

                this.ctx.restore();
            }

            drawTarget() {
                // 绘制目标区域
                this.ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
                this.ctx.fillRect(this.target.x, this.target.y, this.target.width, this.target.height);

                // 绘制目标边框
                this.ctx.strokeStyle = '#4caf50';
                this.ctx.lineWidth = 3;
                this.ctx.strokeRect(this.target.x, this.target.y, this.target.width, this.target.height);

                // 绘制目标标记
                const centerX = this.target.x + this.target.width / 2;
                const centerY = this.target.y + this.target.height / 2;

                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, 15, 0, Math.PI * 2);
                this.ctx.fillStyle = '#4caf50';
                this.ctx.fill();

                this.ctx.fillStyle = '#fff';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('🎯', centerX, centerY);
            }

            drawPlayer() {
                // 绘制玩家
                this.ctx.fillStyle = '#ff6b6b';
                this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);

                // 绘制玩家边框
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(this.player.x, this.player.y, this.player.width, this.player.height);

                // 绘制玩家眼睛
                this.ctx.fillStyle = '#fff';
                this.ctx.beginPath();
                this.ctx.arc(this.player.x + 8, this.player.y + 10, 2, 0, Math.PI * 2);
                this.ctx.arc(this.player.x + 22, this.player.y + 10, 2, 0, Math.PI * 2);
                this.ctx.fill();
            }

            gameLoop() {
                this.draw();

                // 检查游戏状态
                if (this.energy <= 0) {
                    this.showMessage("能量耗尽！请重置关卡");
                    setTimeout(() => {
                        this.hideMessage();
                        this.resetLevel();
                    }, 2000);
                }

                this.checkStarCollection();

                // 如果没有正在移动的动画，检查是否可以自动移动
                if (!this.isPlayerMoving) {
                    this.checkWinCondition();
                }

                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // 启动游戏
        const game = new LightShadowGame();
    </script>
</body>
</html>