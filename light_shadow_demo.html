<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…‰å½±è¿·å®« - æ ¸å¿ƒç©æ³•Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .game-container {
            background: rgba(0, 0, 0, 0.9);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .game-header {
            color: #fff;
            text-align: center;
            margin-bottom: 20px;
        }

        .game-header h1 {
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            color: #fff;
            font-size: 14px;
        }

        .info-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 5px;
        }

        #gameCanvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            display: block;
            background: #000;
        }

        .controls {
            margin-top: 20px;
            text-align: center;
        }

        .control-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 10px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .control-btn.solve {
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
        }

        .control-btn.solve:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .control-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .instructions {
            color: #fff;
            text-align: center;
            margin-top: 15px;
            font-size: 14px;
            line-height: 1.5;
            max-width: 600px;
        }

        .success-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 18px;
            display: none;
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .level-indicator {
            color: #ffd700;
            font-weight: bold;
        }

        .energy-bar {
            width: 200px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .energy-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffed4e);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1>ğŸŒŸ å…‰å½±è¿·å®« ğŸŒŸ</h1>
            <p>ç§»åŠ¨å…‰æºæ”¹å˜å½±å­ï¼Œæ­å»ºé€šè·¯åˆ°è¾¾ç›®æ ‡</p>
        </div>

        <div class="game-info">
            <div class="info-item">å…³å¡: <span class="level-indicator" id="currentLevel">1</span>/3</div>
            <div class="info-item">
                èƒ½é‡:
                <div class="energy-bar" style="display: inline-block; vertical-align: middle;">
                    <div class="energy-fill" id="energyFill" style="width: 100%;"></div>
                </div>
            </div>
            <div class="info-item">æ­¥æ•°: <span id="moveCount">0</span></div>
        </div>

        <canvas id="gameCanvas" width="800" height="500"></canvas>

        <div class="controls">
            <button class="control-btn" onclick="game.resetLevel()">é‡ç½®å…³å¡</button>
            <button class="control-btn" onclick="game.nextLevel()">ä¸‹ä¸€å…³</button>
            <button class="control-btn solve" onclick="game.autoSolve()" id="solveBtn">è‡ªåŠ¨æ±‚è§£</button>
            <button class="control-btn" onclick="game.checkAndAutoMove()">è‡ªåŠ¨ç§»åŠ¨</button>
            <button class="control-btn" onclick="game.debugShadows()">è°ƒè¯•å½±å­</button>
            <button class="control-btn" onclick="game.toggleHelp()">å¸®åŠ©</button>
        </div>

        <div class="instructions">
            <p><strong>æ“ä½œè¯´æ˜ï¼š</strong> ç‚¹å‡»å…‰æºæ‹–åŠ¨ç§»åŠ¨ â€¢ å½±å­ä¼šå®æ—¶å˜åŒ– â€¢ æ­å»ºå½±å­é€šè·¯åˆ°è¾¾ç»¿è‰²ç›®æ ‡</p>
            <p><strong>ç›®æ ‡ï¼š</strong> ä½¿ç”¨æœ€å°‘çš„èƒ½é‡å’Œæ­¥æ•°å®Œæˆå…³å¡ â€¢ æ”¶é›†æ˜Ÿæ˜Ÿè·å¾—é¢å¤–å¥–åŠ±</p>
        </div>

        <div class="success-message" id="successMessage">
            ğŸ‰ å…³å¡å®Œæˆï¼ğŸ‰
        </div>
    </div>

    <script>
        class LightShadowGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.currentLevel = 0;
                this.moveCount = 0;
                this.energy = 100;
                this.maxEnergy = 100;
                this.isDragging = false;
                this.selectedLight = null;
                this.stars = [];
                this.collectedStars = 0;
                this.isAutoSolving = false;
                this.autoSolveSteps = [];
                this.autoSolveIndex = 0;
                this.isPlayerMoving = false;

                this.levels = [
                    {
                        name: "åˆè¯†å…‰å½±",
                        lightSources: [
                            { x: 200, y: 100, radius: 150, color: '#ffd700', id: 'light1' }
                        ],
                        obstacles: [
                            { x: 300, y: 200, width: 50, height: 200 },
                            { x: 500, y: 100, width: 50, height: 150 }
                        ],
                        target: { x: 700, y: 400, width: 60, height: 60 },
                        player: { x: 100, y: 400, width: 30, height: 30 },
                        stars: [
                            { x: 400, y: 300, collected: false },
                            { x: 600, y: 200, collected: false }
                        ]
                    },
                    {
                        name: "åŒé‡å…‰æº",
                        lightSources: [
                            { x: 150, y: 150, radius: 120, color: '#ffd700', id: 'light1' },
                            { x: 650, y: 150, radius: 120, color: '#87ceeb', id: 'light2' }
                        ],
                        obstacles: [
                            { x: 250, y: 200, width: 40, height: 150 },
                            { x: 450, y: 100, width: 40, height: 200 },
                            { x: 350, y: 350, width: 200, height: 40 }
                        ],
                        target: { x: 700, y: 450, width: 60, height: 60 },
                        player: { x: 100, y: 450, width: 30, height: 30 },
                        stars: [
                            { x: 400, y: 250, collected: false },
                            { x: 550, y: 400, collected: false },
                            { x: 250, y: 350, collected: false }
                        ]
                    },
                    {
                        name: "å…‰å½±è¿·å®«",
                        lightSources: [
                            { x: 100, y: 100, radius: 100, color: '#ffd700', id: 'light1' },
                            { x: 400, y: 250, radius: 80, color: '#ff69b4', id: 'light2' },
                            { x: 700, y: 100, radius: 120, color: '#87ceeb', id: 'light3' }
                        ],
                        obstacles: [
                            { x: 200, y: 150, width: 30, height: 100 },
                            { x: 300, y: 50, width: 30, height: 150 },
                            { x: 400, y: 200, width: 30, height: 200 },
                            { x: 500, y: 100, width: 30, height: 150 },
                            { x: 600, y: 250, width: 30, height: 100 },
                            { x: 200, y: 350, width: 400, height: 30 }
                        ],
                        target: { x: 750, y: 450, width: 60, height: 60 },
                        player: { x: 50, y: 450, width: 30, height: 30 },
                        stars: [
                            { x: 250, y: 250, collected: false },
                            { x: 550, y: 150, collected: false },
                            { x: 400, y: 400, collected: false },
                            { x: 650, y: 350, collected: false }
                        ]
                    }
                ];

                this.init();
            }

            init() {
                this.loadLevel(0);
                this.setupEventListeners();
                this.gameLoop();
            }

            loadLevel(levelIndex) {
                if (levelIndex >= this.levels.length) {
                    this.showMessage("ğŸŠ æ­å–œé€šå…³æ‰€æœ‰å…³å¡ï¼ğŸŠ");
                    return;
                }

                this.currentLevel = levelIndex;
                const level = this.levels[levelIndex];

                // æ·±æ‹·è´å…³å¡æ•°æ®
                this.lightSources = JSON.parse(JSON.stringify(level.lightSources));
                this.obstacles = JSON.parse(JSON.stringify(level.obstacles));
                this.target = JSON.parse(JSON.stringify(level.target));
                this.player = JSON.parse(JSON.stringify(level.player));
                this.stars = JSON.parse(JSON.stringify(level.stars));

                this.moveCount = 0;
                this.energy = this.maxEnergy;
                this.collectedStars = 0;
                this.updateUI();
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
            }

            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†å…‰æº
                for (let light of this.lightSources) {
                    const dist = Math.sqrt((x - light.x) ** 2 + (y - light.y) ** 2);
                    if (dist < 20) {
                        this.isDragging = true;
                        this.selectedLight = light;
                        break;
                    }
                }
            }

            handleMouseMove(e) {
                if (!this.isDragging || !this.selectedLight) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                this.selectedLight.x = x;
                this.selectedLight.y = y;
            }

            handleMouseUp(e) {
                if (this.isDragging) {
                    this.moveCount++;
                    this.energy = Math.max(0, this.energy - 5);
                    this.updateUI();
                }
                this.isDragging = false;
                this.selectedLight = null;
            }

            handleTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                this.canvas.dispatchEvent(mouseEvent);
            }

            handleTouchMove(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                this.canvas.dispatchEvent(mouseEvent);
            }

            handleTouchEnd(e) {
                e.preventDefault();
                const mouseEvent = new MouseEvent('mouseup', {});
                this.canvas.dispatchEvent(mouseEvent);
            }

            calculateShadows() {
                const shadows = [];

                for (let light of this.lightSources) {
                    for (let obstacle of this.obstacles) {
                        // è®¡ç®—éšœç¢ç‰©çš„å½±å­
                        const shadow = this.calculateObstacleShadow(light, obstacle);
                        if (shadow) {
                            shadows.push(shadow);
                        }
                    }
                }

                return shadows;
            }

            calculateObstacleShadow(light, obstacle) {
                const corners = [
                    { x: obstacle.x, y: obstacle.y },
                    { x: obstacle.x + obstacle.width, y: obstacle.y },
                    { x: obstacle.x + obstacle.width, y: obstacle.y + obstacle.height },
                    { x: obstacle.x, y: obstacle.y + obstacle.height }
                ];

                // è®¡ç®—å“ªäº›è§’ç‚¹åœ¨å…‰ç…§èŒƒå›´å†…
                const litCorners = [];
                const shadowCorners = [];

                for (let corner of corners) {
                    const dx = corner.x - light.x;
                    const dy = corner.y - light.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < light.radius) {
                        litCorners.push(corner);
                    } else {
                        shadowCorners.push(corner);
                    }
                }

                // å¦‚æœæ‰€æœ‰è§’ç‚¹éƒ½è¢«ç…§äº®æˆ–éƒ½åœ¨é˜´å½±ä¸­ï¼Œä¸äº§ç”Ÿå½±å­
                if (litCorners.length === 0 || litCorners.length === 4) {
                    return null;
                }

                // åˆ›å»ºå½±å­å¤šè¾¹å½¢
                const shadowPoints = [];

                // æ·»åŠ è¢«ç…§äº®çš„è§’ç‚¹
                for (let corner of litCorners) {
                    shadowPoints.push(corner);
                }

                // ä¸ºæ¯ä¸ªè¢«ç…§äº®çš„è§’ç‚¹è®¡ç®—å»¶ä¼¸ç‚¹
                for (let corner of litCorners) {
                    const dx = corner.x - light.x;
                    const dy = corner.y - light.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 0) {
                        const extendX = (dx / distance) * 500;
                        const extendY = (dy / distance) * 500;
                        shadowPoints.push({
                            x: corner.x + extendX,
                            y: corner.y + extendY
                        });
                    }
                }

                // æ·»åŠ æœªè¢«ç…§äº®çš„è§’ç‚¹
                for (let corner of shadowCorners) {
                    shadowPoints.push(corner);
                }

                return {
                    points: shadowPoints,
                    color: 'rgba(0, 0, 0, 0.8)'
                };
            }

            checkWinCondition() {
                // æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨ç›®æ ‡åŒºåŸŸ
                if (this.player.x < this.target.x + this.target.width &&
                    this.player.x + this.player.width > this.target.x &&
                    this.player.y < this.target.y + this.target.height &&
                    this.player.y + this.player.height > this.target.y) {
                    this.showMessage("ğŸ‰ å…³å¡å®Œæˆï¼ğŸ‰");
                    setTimeout(() => {
                        this.hideMessage();
                        // è‡ªåŠ¨è¿›å…¥ä¸‹ä¸€å…³
                        setTimeout(() => {
                            this.nextLevel();
                        }, 1000);
                    }, 2000);
                    return true;
                }
                return false;
            }

            // æ–°å¢ï¼šæ£€æŸ¥æ˜¯å¦æœ‰è·¯å¾„å¹¶è‡ªåŠ¨ç§»åŠ¨
            checkAndAutoMove() {
                if (this.hasPathToTarget()) {
                    this.animatePlayerToTarget(() => {
                        // ç§»åŠ¨å®Œæˆåï¼Œæ£€æŸ¥èƒœåˆ©æ¡ä»¶
                        this.checkWinCondition();
                    });
                    return true;
                }
                return false;
            }

            checkStarCollection() {
                for (let star of this.stars) {
                    if (!star.collected &&
                        this.player.x < star.x + 20 &&
                        this.player.x + this.player.width > star.x - 10 &&
                        this.player.y < star.y + 20 &&
                        this.player.y + this.player.height > star.y - 10) {
                        star.collected = true;
                        this.collectedStars++;
                        this.energy = Math.min(this.maxEnergy, this.energy + 10);
                        this.updateUI();
                    }
                }
            }

            updateUI() {
                document.getElementById('currentLevel').textContent = this.currentLevel + 1;
                document.getElementById('moveCount').textContent = this.moveCount;
                document.getElementById('energyFill').style.width = `${(this.energy / this.maxEnergy) * 100}%`;
            }

            showMessage(text) {
                const messageEl = document.getElementById('successMessage');
                messageEl.textContent = text;
                messageEl.style.display = 'block';
            }

            hideMessage() {
                document.getElementById('successMessage').style.display = 'none';
            }

            resetLevel() {
                this.loadLevel(this.currentLevel);
            }

            nextLevel() {
                this.loadLevel(this.currentLevel + 1);
            }

            toggleHelp() {
                alert("æ¸¸æˆç›®æ ‡ï¼šç§»åŠ¨å…‰æºæ”¹å˜å½±å­ä½ç½®ï¼Œæ­å»ºå½±å­é€šè·¯è®©è§’è‰²åˆ°è¾¾ç»¿è‰²ç›®æ ‡åŒºåŸŸã€‚\n\næ“ä½œï¼šç‚¹å‡»å¹¶æ‹–åŠ¨å…‰æºæ¥ç§»åŠ¨ä½ç½®ã€‚\næç¤ºï¼šæ”¶é›†æ˜Ÿæ˜Ÿå¯ä»¥æ¢å¤èƒ½é‡ï¼\n\nè‡ªåŠ¨æ±‚è§£ï¼šç‚¹å‡»'è‡ªåŠ¨æ±‚è§£'æŒ‰é’®ï¼ŒAIä¼šè‡ªåŠ¨å¸®ä½ å®Œæˆå…³å¡ï¼");
            }

            autoSolve() {
                if (this.isAutoSolving) {
                    this.stopAutoSolve();
                    return;
                }

                this.isAutoSolving = true;
                this.autoSolveIndex = 0;
                this.autoSolveSteps = this.calculateAutoSolveSteps();

                const solveBtn = document.getElementById('solveBtn');
                solveBtn.textContent = 'åœæ­¢æ±‚è§£';
                solveBtn.style.background = 'linear-gradient(45deg, #666, #888)';

                this.showMessage("ğŸ¤– AIæ­£åœ¨æ€è€ƒè§£å†³æ–¹æ¡ˆ...");
                setTimeout(() => {
                    this.hideMessage();
                    this.executeAutoSolve();
                }, 1500);
            }

            stopAutoSolve() {
                this.isAutoSolving = false;
                const solveBtn = document.getElementById('solveBtn');
                solveBtn.textContent = 'è‡ªåŠ¨æ±‚è§£';
                solveBtn.style.background = 'linear-gradient(45deg, #ff6b6b, #ff8e53)';
            }

            calculateAutoSolveSteps() {
                const steps = [];
                const level = this.levels[this.currentLevel];

                // æ ¹æ®ä¸åŒå…³å¡é¢„è®¾è§£å†³æ–¹æ¡ˆ
                switch (this.currentLevel) {
                    case 0:
                        // ç¬¬ä¸€å…³ï¼šç§»åŠ¨å…‰æºåˆ°æ­£ç¡®ä½ç½®ï¼Œè®©å½±å­è¿æ¥ç©å®¶å’Œç›®æ ‡
                        steps.push(
                            { lightIndex: 0, x: 400, y: 150, delay: 1200 }
                        );
                        break;
                    case 1:
                        // ç¬¬äºŒå…³ï¼šè°ƒæ•´ä¸¤ä¸ªå…‰æºï¼Œæ­å»ºå®Œæ•´çš„å½±å­é€šè·¯
                        steps.push(
                            { lightIndex: 0, x: 200, y: 300, delay: 1000 },
                            { lightIndex: 1, x: 600, y: 300, delay: 1200 }
                        );
                        break;
                    case 2:
                        // ç¬¬ä¸‰å…³ï¼šåè°ƒä¸‰ä¸ªå…‰æºï¼Œåˆ›å»ºå¤æ‚çš„å½±å­è·¯å¾„
                        steps.push(
                            { lightIndex: 0, x: 150, y: 250, delay: 1000 },
                            { lightIndex: 1, x: 400, y: 350, delay: 1200 },
                            { lightIndex: 2, x: 700, y: 250, delay: 1000 }
                        );
                        break;
                }

                return steps;
            }

            executeAutoSolve() {
                if (!this.isAutoSolving || this.autoSolveIndex >= this.autoSolveSteps.length) {
                    // æ‰€æœ‰å…‰æºç§»åŠ¨å®Œæˆåï¼Œæ£€æŸ¥æ˜¯å¦æœ‰è·¯å¾„å¯ä»¥åˆ°è¾¾ç›®æ ‡
                    if (this.hasPathToTarget()) {
                        this.animatePlayerToTarget(() => {
                            this.showMessage("ğŸ‰ AIæˆåŠŸå®Œæˆå…³å¡ï¼ğŸ‰");
                            setTimeout(() => {
                                this.hideMessage();
                                this.stopAutoSolve();
                                setTimeout(() => {
                                    this.nextLevel();
                                }, 2000);
                            }, 2000);
                        });
                    } else {
                        this.showMessage("âŒ AIéœ€è¦è°ƒæ•´ç­–ç•¥...");
                        setTimeout(() => {
                            this.hideMessage();
                            this.stopAutoSolve();
                        }, 2000);
                    }
                    return;
                }

                const step = this.autoSolveSteps[this.autoSolveIndex];
                const light = this.lightSources[step.lightIndex];

                // åˆ›å»ºå¹³æ»‘ç§»åŠ¨åŠ¨ç”»
                this.animateLightMove(light, step.x, step.y, () => {
                    this.moveCount++;
                    this.energy = Math.max(0, this.energy - 5);
                    this.updateUI();

                    this.autoSolveIndex++;
                    setTimeout(() => {
                        this.executeAutoSolve();
                    }, step.delay);
                });
            }

            animateLightMove(light, targetX, targetY, callback) {
                const startX = light.x;
                const startY = light.y;
                const duration = 800; // åŠ¨ç”»æŒç»­æ—¶é—´
                const startTime = Date.now();

                const animate = () => {
                    if (!this.isAutoSolving) return;

                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°è®©ç§»åŠ¨æ›´è‡ªç„¶
                    const easeProgress = this.easeInOutCubic(progress);

                    light.x = startX + (targetX - startX) * easeProgress;
                    light.y = startY + (targetY - startY) * easeProgress;

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        if (callback) callback();
                    }
                };

                animate();
            }

            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }

            hasPathToTarget() {
                // æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨å½±å­å†…ï¼Œå¹¶ä¸”å½±å­è¾¹ç•Œæ¥è§¦æˆ–æ¥è¿‘ç›®æ ‡åŒºåŸŸ
                const shadows = this.calculateShadows();
                const playerCenter = {
                    x: this.player.x + this.player.width / 2,
                    y: this.player.y + this.player.height / 2
                };

                // æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨å½±å­åŒºåŸŸå†…
                let playerInShadow = false;
                let shadowNearTarget = false;

                for (let shadow of shadows) {
                    if (!shadow || shadow.points.length < 3) continue;

                    // æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨å½±å­å†…
                    if (this.pointInPolygon(playerCenter, shadow.points)) {
                        playerInShadow = true;
                    }

                    // æ£€æŸ¥å½±å­æ˜¯å¦æœ‰ç‚¹æ¥è¿‘ç›®æ ‡åŒºåŸŸ
                    for (let point of shadow.points) {
                        const distToTarget = this.distanceToTarget(point.x, point.y);
                        if (distToTarget < 100) { // 100åƒç´ å†…è®¤ä¸ºæ¥è¿‘
                            shadowNearTarget = true;
                        }
                    }
                }

                // å¯¹äºç¬¬ä¸€å…³çš„ç‰¹æ®Šå¤„ç†ï¼šç®€åŒ–æ£€æµ‹é€»è¾‘
                if (this.currentLevel === 0) {
                    return playerInShadow && shadowNearTarget;
                }

                // å¯¹äºå…¶ä»–å…³å¡ï¼Œæ£€æŸ¥å½±å­æ˜¯å¦æä¾›äº†ä»ç©å®¶åˆ°ç›®æ ‡çš„è·¯å¾„
                return playerInShadow && shadowNearTarget;
            }

            distanceToTarget(x, y) {
                const targetCenterX = this.target.x + this.target.width / 2;
                const targetCenterY = this.target.y + this.target.height / 2;
                return Math.sqrt((x - targetCenterX) ** 2 + (y - targetCenterY) ** 2);
            }

            pointInPolygon(point, polygon) {
                let inside = false;
                for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                    const xi = polygon[i].x, yi = polygon[i].y;
                    const xj = polygon[j].x, yj = polygon[j].y;

                    const intersect = ((yi > point.y) != (yj > point.y))
                        && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }

            debugShadows() {
                const shadows = this.calculateShadows();
                const playerCenter = {
                    x: this.player.x + this.player.width / 2,
                    y: this.player.y + this.player.height / 2
                };

                let debugInfo = "=== å½±å­è°ƒè¯•ä¿¡æ¯ ===\n";
                debugInfo += `ç©å®¶ä½ç½®: (${Math.round(playerCenter.x)}, ${Math.round(playerCenter.y)})\n`;
                debugInfo += `ç›®æ ‡ä½ç½®: (${this.target.x + this.target.width/2}, ${this.target.y + this.target.height/2})\n`;
                debugInfo += `å½±å­æ•°é‡: ${shadows.length}\n\n`;

                let playerInShadow = false;
                let shadowNearTarget = false;

                for (let i = 0; i < shadows.length; i++) {
                    const shadow = shadows[i];
                    if (!shadow || shadow.points.length < 3) continue;

                    debugInfo += `å½±å­ ${i + 1}:\n`;
                    debugInfo += `  ç‚¹æ•°: ${shadow.points.length}\n`;
                    debugInfo += `  ç©å®¶åœ¨å½±å­å†…: ${this.pointInPolygon(playerCenter, shadow.points)}\n`;

                    let minDist = Infinity;
                    for (let point of shadow.points) {
                        const distToTarget = this.distanceToTarget(point.x, point.y);
                        minDist = Math.min(minDist, distToTarget);
                    }
                    debugInfo += `  åˆ°ç›®æ ‡æœ€è¿‘è·ç¦»: ${Math.round(minDist)}\n`;

                    if (this.pointInPolygon(playerCenter, shadow.points)) {
                        playerInShadow = true;
                    }
                    if (minDist < 100) {
                        shadowNearTarget = true;
                    }
                    debugInfo += "\n";
                }

                debugInfo += `=== æ£€æµ‹ç»“æœ ===\n`;
                debugInfo += `ç©å®¶åœ¨å½±å­å†…: ${playerInShadow}\n`;
                debugInfo += `å½±å­æ¥è¿‘ç›®æ ‡: ${shadowNearTarget}\n`;
                debugInfo += `å¯ä»¥é€šè¿‡: ${this.hasPathToTarget()}\n`;

                alert(debugInfo);
            }

            animatePlayerToTarget(callback) {
                const startX = this.player.x;
                const startY = this.player.y;
                const targetX = this.target.x + this.target.width / 2 - this.player.width / 2;
                const targetY = this.target.y + this.target.height / 2 - this.player.height / 2;
                const duration = 1500;
                const startTime = Date.now();

                this.isPlayerMoving = true;

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const easeProgress = this.easeInOutCubic(progress);

                    this.player.x = startX + (targetX - startX) * easeProgress;
                    this.player.y = startY + (targetY - startY) * easeProgress;

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.isPlayerMoving = false;
                        if (callback) callback();
                    }
                };

                animate();
            }

            draw() {
                // æ¸…ç©ºç”»å¸ƒ
                this.ctx.fillStyle = '#0a0a0a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯
                this.drawGrid();

                // ç»˜åˆ¶å…‰æº
                for (let light of this.lightSources) {
                    this.drawLight(light);
                }

                // è®¡ç®—å¹¶ç»˜åˆ¶å½±å­
                const shadows = this.calculateShadows();
                for (let shadow of shadows) {
                    this.drawShadow(shadow);
                }

                // ç»˜åˆ¶éšœç¢ç‰©
                for (let obstacle of this.obstacles) {
                    this.drawObstacle(obstacle);
                }

                // ç»˜åˆ¶æ˜Ÿæ˜Ÿ
                for (let star of this.stars) {
                    if (!star.collected) {
                        this.drawStar(star);
                    }
                }

                // ç»˜åˆ¶ç›®æ ‡
                this.drawTarget();

                // ç»˜åˆ¶ç©å®¶
                this.drawPlayer();

                // ç»˜åˆ¶å…‰æºä½ç½®æç¤ºï¼ˆå¦‚æœæ­£åœ¨æ‹–åŠ¨æˆ–è‡ªåŠ¨æ±‚è§£ï¼‰
                if ((this.isDragging && this.selectedLight) || this.isAutoSolving) {
                    for (let light of this.lightSources) {
                        this.drawLightRadius(light);
                    }
                }
            }

            drawGrid() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                this.ctx.lineWidth = 1;

                for (let x = 0; x < this.canvas.width; x += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }

                for (let y = 0; y < this.canvas.height; y += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }

            drawLight(light) {
                // ç»˜åˆ¶å…‰æ™•
                const gradient = this.ctx.createRadialGradient(light.x, light.y, 0, light.x, light.y, light.radius);
                gradient.addColorStop(0, light.color + '40');
                gradient.addColorStop(0.5, light.color + '20');
                gradient.addColorStop(1, 'transparent');

                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // ç»˜åˆ¶å…‰æºæ ¸å¿ƒ
                this.ctx.beginPath();
                this.ctx.arc(light.x, light.y, 8, 0, Math.PI * 2);
                this.ctx.fillStyle = light.color;
                this.ctx.fill();

                // ç»˜åˆ¶å…‰æºè¾¹æ¡†
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
            }

            drawLightRadius(light) {
                // å¦‚æœæ­£åœ¨è‡ªåŠ¨æ±‚è§£ï¼Œæ˜¾ç¤ºç‰¹æ®Šçš„AIæ±‚è§£æ•ˆæœ
                if (this.isAutoSolving) {
                    const time = Date.now() / 1000;
                    const pulseAlpha = 0.3 + Math.sin(time * 3) * 0.2;
                    this.ctx.strokeStyle = light.color + Math.floor(pulseAlpha * 255).toString(16).padStart(2, '0');
                    this.ctx.lineWidth = 3;
                } else {
                    this.ctx.strokeStyle = light.color + '60';
                    this.ctx.lineWidth = 2;
                }

                this.ctx.beginPath();
                this.ctx.arc(light.x, light.y, light.radius, 0, Math.PI * 2);
                this.ctx.setLineDash([5, 5]);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }

            drawShadow(shadow) {
                if (!shadow || shadow.points.length < 3) return;

                this.ctx.beginPath();
                this.ctx.moveTo(shadow.points[0].x, shadow.points[0].y);
                for (let i = 1; i < shadow.points.length; i++) {
                    this.ctx.lineTo(shadow.points[i].x, shadow.points[i].y);
                }
                this.ctx.closePath();

                this.ctx.fillStyle = shadow.color;
                this.ctx.fill();

                // æ·»åŠ å½±å­è¾¹ç¼˜é«˜å…‰æ•ˆæœ
                this.ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
            }

            drawObstacle(obstacle) {
                // ç»˜åˆ¶éšœç¢ç‰©ä¸»ä½“
                this.ctx.fillStyle = '#4a4a4a';
                this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

                // ç»˜åˆ¶éšœç¢ç‰©è¾¹æ¡†
                this.ctx.strokeStyle = '#666';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            }

            drawStar(star) {
                const time = Date.now() / 1000;
                const scale = 1 + Math.sin(time * 3) * 0.1;

                this.ctx.save();
                this.ctx.translate(star.x, star.y);
                this.ctx.scale(scale, scale);

                // ç»˜åˆ¶æ˜Ÿæ˜Ÿ
                this.ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                    const x = Math.cos(angle) * 10;
                    const y = Math.sin(angle) * 10;
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.closePath();

                this.ctx.fillStyle = '#ffd700';
                this.ctx.fill();
                this.ctx.strokeStyle = '#ffed4e';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();

                this.ctx.restore();
            }

            drawTarget() {
                // ç»˜åˆ¶ç›®æ ‡åŒºåŸŸ
                this.ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
                this.ctx.fillRect(this.target.x, this.target.y, this.target.width, this.target.height);

                // ç»˜åˆ¶ç›®æ ‡è¾¹æ¡†
                this.ctx.strokeStyle = '#4caf50';
                this.ctx.lineWidth = 3;
                this.ctx.strokeRect(this.target.x, this.target.y, this.target.width, this.target.height);

                // ç»˜åˆ¶ç›®æ ‡æ ‡è®°
                const centerX = this.target.x + this.target.width / 2;
                const centerY = this.target.y + this.target.height / 2;

                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, 15, 0, Math.PI * 2);
                this.ctx.fillStyle = '#4caf50';
                this.ctx.fill();

                this.ctx.fillStyle = '#fff';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('ğŸ¯', centerX, centerY);
            }

            drawPlayer() {
                // ç»˜åˆ¶ç©å®¶
                this.ctx.fillStyle = '#ff6b6b';
                this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);

                // ç»˜åˆ¶ç©å®¶è¾¹æ¡†
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(this.player.x, this.player.y, this.player.width, this.player.height);

                // ç»˜åˆ¶ç©å®¶çœ¼ç›
                this.ctx.fillStyle = '#fff';
                this.ctx.beginPath();
                this.ctx.arc(this.player.x + 8, this.player.y + 10, 2, 0, Math.PI * 2);
                this.ctx.arc(this.player.x + 22, this.player.y + 10, 2, 0, Math.PI * 2);
                this.ctx.fill();
            }

            gameLoop() {
                this.draw();

                // æ£€æŸ¥æ¸¸æˆçŠ¶æ€
                if (this.energy <= 0) {
                    this.showMessage("èƒ½é‡è€—å°½ï¼è¯·é‡ç½®å…³å¡");
                    setTimeout(() => {
                        this.hideMessage();
                        this.resetLevel();
                    }, 2000);
                }

                this.checkStarCollection();

                // å¦‚æœæ²¡æœ‰æ­£åœ¨ç§»åŠ¨çš„åŠ¨ç”»ï¼Œæ£€æŸ¥æ˜¯å¦å¯ä»¥è‡ªåŠ¨ç§»åŠ¨
                if (!this.isPlayerMoving) {
                    this.checkWinCondition();
                }

                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        const game = new LightShadowGame();
    </script>
</body>
</html>