<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>集体智慧 - 大规模群体行为演示</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            text-align: center;
            backdrop-filter: blur(10px);
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.5);
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            font-size: 14px;
            color: #aaa;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-value {
            color: #4fc3f7;
            font-weight: bold;
            font-size: 16px;
        }

        .main-container {
            flex: 1;
            display: flex;
            position: relative;
        }

        .sidebar {
            width: 280px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border-right: 2px solid rgba(255, 255, 255, 0.1);
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group h3 {
            margin-bottom: 15px;
            color: #4fc3f7;
            font-size: 16px;
            border-bottom: 1px solid rgba(79, 195, 247, 0.3);
            padding-bottom: 5px;
        }

        .control-item {
            margin-bottom: 12px;
        }

        .control-item label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #ccc;
        }

        .slider {
            width: 100%;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
        }

        .btn {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: linear-gradient(45deg, #4fc3f7, #29b6f6);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(79, 195, 247, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(79, 195, 247, 0.5);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.danger {
            background: linear-gradient(45deg, #f44336, #e91e63);
            box-shadow: 0 2px 10px rgba(244, 67, 54, 0.3);
        }

        .btn.danger:hover {
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.5);
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: #000;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        .performance-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #4fc3f7;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(79, 195, 247, 0.3);
        }

        .info-panel {
            margin-top: 20px;
            padding: 15px;
            background: rgba(79, 195, 247, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(79, 195, 247, 0.3);
        }

        .info-panel h4 {
            margin-bottom: 10px;
            color: #4fc3f7;
        }

        .info-panel p {
            font-size: 12px;
            line-height: 1.4;
            color: #ccc;
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
        }

        .checkbox-wrapper input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .checkbox-wrapper label {
            font-size: 13px;
            color: #ccc;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🧬 集体智慧 - 大规模群体行为演示</h1>
        <div class="stats">
            <div class="stat-item">
                <span>单位数量:</span>
                <span class="stat-value" id="unitCount">1000</span>
            </div>
            <div class="stat-item">
                <span>帧率:</span>
                <span class="stat-value" id="fps">60</span>
            </div>
            <div class="stat-item">
                <span>渲染时间:</span>
                <span class="stat-value" id="renderTime">0ms</span>
            </div>
            <div class="stat-item">
                <span>内存使用:</span>
                <span class="stat-value" id="memory">0MB</span>
            </div>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="control-group">
                <h3>🎮 群体控制</h3>
                <div class="control-item">
                    <label>单位数量: <span id="countDisplay">1000</span></label>
                    <input type="range" class="slider" id="countSlider" min="100" max="5000" value="1000" step="100">
                </div>
                <div class="control-item">
                    <label>凝聚强度: <span id="cohesionDisplay">1.0</span></label>
                    <input type="range" class="slider" id="cohesionSlider" min="0" max="2" value="1" step="0.1">
                </div>
                <div class="control-item">
                    <label>分离距离: <span id="separationDisplay">25</span></label>
                    <input type="range" class="slider" id="separationSlider" min="10" max="50" value="25" step="5">
                </div>
                <div class="control-item">
                    <label>对齐强度: <span id="alignmentDisplay">1.0</span></label>
                    <input type="range" class="slider" id="alignmentSlider" min="0" max="2" value="1" step="0.1">
                </div>
                <div class="control-item">
                    <label>移动速度: <span id="speedDisplay">2.0</span></label>
                    <input type="range" class="slider" id="speedSlider" min="0.5" max="5" value="2" step="0.5">
                </div>
            </div>

            <div class="control-group">
                <h3>🎨 视觉效果</h3>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="showTrails" checked>
                    <label for="showTrails">显示轨迹</label>
                </div>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="showConnections" checked>
                    <label for="showConnections">显示连接线</label>
                </div>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="showInfluence">
                    <label for="showInfluence">显示影响范围</label>
                </div>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="showGrid">
                    <label for="showGrid">显示网格</label>
                </div>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="rainbowMode">
                    <label for="rainbowMode">彩虹模式</label>
                </div>
            </div>

            <div class="control-group">
                <h3>🎯 行为模式</h3>
                <button class="btn" onclick="game.setMode('flock')">集群模式</button>
                <button class="btn" onclick="game.setMode('swarm')">蜂群模式</button>
                <button class="btn" onclick="game.setMode('flee')">逃跑模式</button>
                <button class="btn" onclick="game.setMode('orbit')">轨道模式</button>
                <button class="btn" onclick="game.setMode('random')">随机漫步</button>
                <button class="btn" onclick="game.setMode('wave')">波浪模式</button>
            </div>

            <div class="control-group">
                <h3>🎮 游戏控制</h3>
                <button class="btn" onclick="game.startGame()">开始游戏</button>
                <button class="btn" onclick="game.pauseGame()">暂停</button>
                <button class="btn danger" onclick="game.resetGame()">重置游戏</button>
            </div>

            <div class="control-group">
                <h3>📊 游戏状态</h3>
                <div class="stat-item">
                    <span>得分:</span>
                    <span class="stat-value" id="score">0</span>
                </div>
                <div class="stat-item">
                    <span>等级:</span>
                    <span class="stat-value" id="level">1</span>
                </div>
                <div class="stat-item">
                    <span>生命:</span>
                    <span class="stat-value" id="health">100</span>
                </div>
                <div class="stat-item">
                    <span>能量:</span>
                    <span class="stat-value" id="energy">100</span>
                </div>
            </div>

            <div class="control-group">
                <h3>⚡ 技能</h3>
                <button class="btn" onclick="game.useSkill('gather')" id="gatherBtn">聚集 [Q]</button>
                <button class="btn" onclick="game.useSkill('shield')" id="shieldBtn">护盾 [W]</button>
                <button class="btn" onclick="game.useSkill('boost')" id="boostBtn">加速 [E]</button>
                <button class="btn" onclick="game.useSkill('split')" id="splitBtn">分裂 [R]</button>
            </div>

            <div class="info-panel">
                <h4>🎮 游戏玩法</h4>
                <p>• <strong>目标：</strong>引导你的群体收集食物，躲避敌人，生存下去</p>
                <p>• <strong>食物(绿色)</strong>：增加得分和能量</p>
                <p>• <strong>敌人(红色)</strong>：碰撞会损失生命</p>
                <p>• <strong>技能：</strong>使用Q/W/E/R键释放特殊技能</p>
                <p>• <strong>升级：</strong>达到一定分数获得更多单位</p>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="gameCanvas"></canvas>
            <div class="performance-info">
                <div>GPU实例化: <span id="instancing">ON</span></div>
                <div>空间分区: <span id="spatialHashing">ON</span></div>
                <div>批处理渲染: <span id="batching">ON</span></div>
                <div>LOD系统: <span id="lod">ON</span></div>
            </div>
        </div>
    </div>

    <script>
        class GameObject {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = type === 'food' ? 8 : (type === 'enemy' ? 12 : 6);
                this.collected = false;
                this.lifetime = type === 'enemy' ? 600 : 1000; // 10秒敌人，16秒食物
                this.createdAt = Date.now();
                this.pulsePhase = Math.random() * Math.PI * 2;

                if (type === 'food') {
                    this.color = '#4caf50';
                    this.value = 10;
                } else if (type === 'enemy') {
                    this.color = '#f44336';
                    this.damage = 10;
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = (Math.random() - 0.5) * 2;
                }
            }

            update() {
                this.pulsePhase += 0.1;

                if (this.type === 'enemy') {
                    // 敌人简单移动
                    this.x += this.vx;
                    this.y += this.vy;

                    // 边界反弹
                    if (this.x < this.radius || this.x > game.canvas.width - this.radius) {
                        this.vx = -this.vx;
                    }
                    if (this.y < this.radius || this.y > game.canvas.height - this.radius) {
                        this.vy = -this.vy;
                    }
                }

                // 检查生命周期
                if (Date.now() - this.createdAt > this.lifetime) {
                    this.collected = true;
                }
            }

            draw(ctx) {
                if (this.collected) return;

                const pulse = Math.sin(this.pulsePhase) * 0.2 + 1;

                ctx.save();

                // 发光效果
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15 * pulse;

                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * pulse, 0, Math.PI * 2);
                ctx.fill();

                // 中心点
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class Unit {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.ax = 0;
                this.ay = 0;
                this.maxSpeed = 2;
                this.maxForce = 0.05;
                this.radius = 3;
                this.baseColor = `hsl(${Math.random() * 60 + 200}, 70%, 60%)`;
                this.color = this.baseColor;
                this.trail = [];
                this.maxTrailLength = 20;
                this.neighbors = [];
                this.gridCell = null;
                this.isShielded = false;
                this.isBoosted = false;
            }

            update(boids, params, width, height, targetX, targetY) {
                // 重置加速度
                this.ax = 0;
                this.ay = 0;

                // 寻找邻居（优化：使用空间分区）
                this.findNeighbors(boids, params.neighborRadius);

                // 应用不同的行为模式
                switch (params.mode) {
                    case 'flock':
                        this.flock(this.neighbors, params);
                        this.seekTarget(targetX, targetY, params.targetForce);
                        break;
                    case 'swarm':
                        this.swarm(this.neighbors, params);
                        break;
                    case 'flee':
                        this.fleeFromTarget(targetX, targetY, params.targetForce);
                        break;
                    case 'orbit':
                        this.orbit(targetX, targetY, params);
                        break;
                    case 'wave':
                        this.wave(params.time);
                        break;
                    case 'random':
                        this.wander();
                        break;
                }

                // 避免边界
                this.avoidEdges(width, height);

                // 更新速度
                this.vx += this.ax;
                this.vy += this.ay;

                // 限制速度
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > params.maxSpeed) {
                    this.vx = (this.vx / speed) * params.maxSpeed;
                    this.vy = (this.vy / speed) * params.maxSpeed;
                }

                // 更新位置
                this.x += this.vx;
                this.y += this.vy;

                // 更新轨迹
                if (params.showTrails && Math.random() < 0.3) {
                    this.trail.push({ x: this.x, y: this.y, alpha: 1 });
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                }

                // 更新轨迹透明度
                this.trail.forEach(point => {
                    point.alpha *= 0.95;
                });
                this.trail = this.trail.filter(point => point.alpha > 0.01);
            }

            findNeighbors(boids, radius) {
                this.neighbors = [];
                for (let boid of boids) {
                    if (boid !== this) {
                        const dx = boid.x - this.x;
                        const dy = boid.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < radius) {
                            this.neighbors.push({ boid, distance: dist });
                        }
                    }
                }
                this.neighbors.sort((a, b) => a.distance - b.distance);
            }

            flock(neighbors, params) {
                if (neighbors.length === 0) return;

                let separation = { x: 0, y: 0 };
                let alignment = { x: 0, y: 0 };
                let cohesion = { x: 0, y: 0 };
                let count = 0;

                for (let { boid, distance } of neighbors) {
                    // 分离 (Separation)
                    if (distance < params.separationRadius && distance > 0) {
                        const diff = {
                            x: this.x - boid.x,
                            y: this.y - boid.y
                        };
                        const norm = Math.sqrt(diff.x * diff.x + diff.y * diff.y);
                        if (norm > 0) {
                            separation.x += (diff.x / norm) / distance;
                            separation.y += (diff.y / norm) / distance;
                        }
                    }

                    // 对齐 (Alignment)
                    if (distance < params.alignmentRadius) {
                        alignment.x += boid.vx;
                        alignment.y += boid.vy;
                        count++;
                    }

                    // 凝聚 (Cohesion)
                    if (distance < params.cohesionRadius) {
                        cohesion.x += boid.x;
                        cohesion.y += boid.y;
                        count++;
                    }
                }

                // 应用力
                if (count > 0) {
                    // 分离力
                    if (separation.x !== 0 || separation.y !== 0) {
                        const sepMag = Math.sqrt(separation.x * separation.x + separation.y * separation.y);
                        if (sepMag > 0) {
                            this.ax += (separation.x / sepMag) * params.separationForce;
                            this.ay += (separation.y / sepMag) * params.separationForce;
                        }
                    }

                    // 对齐力
                    alignment.x /= count;
                    alignment.y /= count;
                    this.ax += (alignment.x - this.vx) * params.alignmentForce;
                    this.ay += (alignment.y - this.vy) * params.alignmentForce;

                    // 凝聚力
                    cohesion.x /= count;
                    cohesion.y /= count;
                    this.ax += (cohesion.x - this.x) * params.cohesionForce * 0.01;
                    this.ay += (cohesion.y - this.y) * params.cohesionForce * 0.01;
                }
            }

            swarm(neighbors, params) {
                // 蜂群模式：更强的凝聚性，更弱的分离
                if (neighbors.length === 0) return;

                let center = { x: 0, y: 0 };
                let separation = { x: 0, y: 0 };

                for (let { boid, distance } of neighbors) {
                    center.x += boid.x;
                    center.y += boid.y;

                    if (distance < params.separationRadius * 0.5) {
                        const diff = {
                            x: this.x - boid.x,
                            y: this.y - boid.y
                        };
                        const norm = Math.sqrt(diff.x * diff.x + diff.y * diff.y);
                        if (norm > 0) {
                            separation.x += (diff.x / norm) / distance;
                            separation.y += (diff.y / norm) / distance;
                        }
                    }
                }

                center.x /= neighbors.length;
                center.y /= neighbors.length;

                // 强力凝聚
                this.ax += (center.x - this.x) * params.cohesionForce * 0.02;
                this.ay += (center.y - this.y) * params.cohesionForce * 0.02;

                // 弱分离
                if (separation.x !== 0 || separation.y !== 0) {
                    const sepMag = Math.sqrt(separation.x * separation.x + separation.y * separation.y);
                    if (sepMag > 0) {
                        this.ax += (separation.x / sepMag) * params.separationForce * 0.5;
                        this.ay += (separation.y / sepMag) * params.separationForce * 0.5;
                    }
                }
            }

            seekTarget(targetX, targetY, force) {
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 5) {
                    this.ax += (dx / dist) * force;
                    this.ay += (dy / dist) * force;
                }
            }

            fleeFromTarget(targetX, targetY, force) {
                const dx = this.x - targetX;
                const dy = this.y - targetY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 200 && dist > 0) {
                    this.ax += (dx / dist) * force * 2;
                    this.ay += (dy / dist) * force * 2;
                }
            }

            orbit(targetX, targetY, params) {
                const dx = this.x - targetX;
                const dy = this.y - targetY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const targetDist = 150 + Math.sin(params.time * 0.001 + this.x * 0.01) * 50;

                if (dist > 0) {
                    // 向目标轨道移动
                    this.ax += ((dx / dist) * (dist - targetDist)) * 0.01;
                    this.ay += ((dy / dist) * (dist - targetDist)) * 0.01;

                    // 切向速度
                    const tangentX = -dy / dist;
                    const tangentY = dx / dist;
                    this.ax += tangentX * params.maxSpeed * 0.5;
                    this.ay += tangentY * params.maxSpeed * 0.5;
                }
            }

            wave(params) {
                // 波浪模式：基于位置和时间产生波动
                const waveX = Math.sin(params.time * 0.001 + this.y * 0.01) * 50;
                const waveY = Math.cos(params.time * 0.001 + this.x * 0.01) * 30;

                this.ax += waveX * 0.01;
                this.ay += waveY * 0.01;
            }

            wander() {
                // 随机漫步
                this.ax += (Math.random() - 0.5) * 0.1;
                this.ay += (Math.random() - 0.5) * 0.1;
            }

            avoidEdges(width, height) {
                const margin = 50;
                const turnForce = 0.5;

                if (this.x < margin) {
                    this.ax += turnForce;
                } else if (this.x > width - margin) {
                    this.ax -= turnForce;
                }

                if (this.y < margin) {
                    this.ay += turnForce;
                } else if (this.y > height - margin) {
                    this.ay -= turnForce;
                }
            }

            draw(ctx, params) {
                // 护盾效果
                if (this.isShielded) {
                    ctx.strokeStyle = 'rgba(100, 200, 255, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // 加速效果
                if (this.isBoosted) {
                    ctx.shadowColor = '#ff9800';
                    ctx.shadowBlur = 15;
                }

                // 绘制轨迹
                if (params.showTrails && this.trail.length > 1) {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.globalAlpha = this.trail[i].alpha * 0.3;
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }

                // 更新颜色（彩虹模式）
                if (params.rainbowMode) {
                    const hue = (params.time * 0.1 + this.x * 0.5 + this.y * 0.5) % 360;
                    this.color = `hsl(${hue}, 70%, 60%)`;
                } else {
                    this.color = this.baseColor;
                }

                // 绘制单位
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0;
            }
        }

        class CollectiveMindGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.units = [];
                this.gameObjects = [];
                this.targetX = 0;
                this.targetY = 0;

                // 游戏状态
                this.gameState = 'menu'; // menu, playing, paused, gameover
                this.score = 0;
                this.level = 1;
                this.health = 100;
                this.energy = 100;
                this.isShielded = false;
                this.skillCooldowns = {
                    gather: 0,
                    shield: 0,
                    boost: 0,
                    split: 0
                };

                this.params = {
                    count: 100,
                    cohesionForce: 1.0,
                    separationForce: 1.0,
                    alignmentForce: 1.0,
                    maxSpeed: 2.0,
                    separationRadius: 25,
                    alignmentRadius: 50,
                    cohesionRadius: 100,
                    neighborRadius: 100,
                    targetForce: 0.5,
                    mode: 'flock',
                    showTrails: true,
                    showConnections: true,
                    showInfluence: false,
                    showGrid: false,
                    rainbowMode: false,
                    time: 0
                };

                this.fps = 60;
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.renderTime = 0;
                this.lastSpawnTime = 0;

                this.init();
                this.setupEventListeners();
                this.gameLoop();
            }

            init() {
                this.resizeCanvas();
                this.createUnits(this.params.count);
                this.targetX = this.canvas.width / 2;
                this.targetY = this.canvas.height / 2;
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
            }

            createUnits(count) {
                this.units = [];
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const radius = Math.random() * 200;
                    const x = this.canvas.width / 2 + Math.cos(angle) * radius;
                    const y = this.canvas.height / 2 + Math.sin(angle) * radius;
                    this.units.push(new Unit(x, y));
                }
            }

            spawnGameObject(type) {
                const margin = 50;
                const x = margin + Math.random() * (this.canvas.width - margin * 2);
                const y = margin + Math.random() * (this.canvas.height - margin * 2);
                this.gameObjects.push(new GameObject(x, y, type));
            }

            checkCollisions() {
                if (this.gameState !== 'playing') return;

                for (let unit of this.units) {
                    for (let obj of this.gameObjects) {
                        if (obj.collected) continue;

                        const dx = unit.x - obj.x;
                        const dy = unit.y - obj.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < unit.radius + obj.radius) {
                            if (obj.type === 'food') {
                                // 收集食物
                                obj.collected = true;
                                this.score += obj.value;
                                this.energy = Math.min(100, this.energy + 5);
                                this.updateUI();
                            } else if (obj.type === 'enemy' && !this.isShielded) {
                                // 碰到敌人
                                this.health -= obj.damage;
                                obj.collected = true;
                                this.updateUI();

                                if (this.health <= 0) {
                                    this.gameOver();
                                }
                            }
                        }
                    }
                }

                // 清理已收集的对象
                this.gameObjects = this.gameObjects.filter(obj => !obj.collected);
            }

            updateGame() {
                if (this.gameState !== 'playing') return;

                const currentTime = Date.now();

                // 生成食物和敌人
                if (currentTime - this.lastSpawnTime > 2000) { // 每2秒生成
                    this.spawnGameObject('food');

                    // 根据等级生成敌人
                    if (Math.random() < this.level * 0.1) {
                        this.spawnGameObject('enemy');
                    }

                    this.lastSpawnTime = currentTime;
                }

                // 更新技能冷却
                for (let skill in this.skillCooldowns) {
                    if (this.skillCooldowns[skill] > 0) {
                        this.skillCooldowns[skill]--;
                    }
                }

                // 检查升级
                if (this.score >= this.level * 100) {
                    this.levelUp();
                }

                // 恢复能量
                if (this.energy < 100) {
                    this.energy = Math.min(100, this.energy + 0.01);
                    this.updateUI();
                }
            }

            levelUp() {
                this.level++;
                this.units.push(new Unit(this.canvas.width / 2, this.canvas.height / 2));
                this.params.count = this.units.length;
                document.getElementById('countSlider').value = this.params.count;
                document.getElementById('countDisplay').textContent = this.params.count;
                this.showMessage(`升级到等级 ${this.level}！`);
            }

            useSkill(skill) {
                if (this.gameState !== 'playing') return;
                if (this.skillCooldowns[skill] > 0) {
                    this.showMessage('技能冷却中...');
                    return;
                }

                switch (skill) {
                    case 'gather':
                        // 聚集技能：所有单位快速聚集到目标
                        this.units.forEach(unit => {
                            const dx = this.targetX - unit.x;
                            const dy = this.targetY - unit.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 0) {
                                unit.vx += (dx / dist) * 5;
                                unit.vy += (dy / dist) * 5;
                            }
                        });
                        this.skillCooldowns.gather = 180; // 3秒冷却
                        this.showMessage('聚集技能释放！');
                        break;

                    case 'shield':
                        // 护盾技能：所有单位获得护盾
                        this.isShielded = true;
                        this.units.forEach(unit => unit.isShielded = true);
                        setTimeout(() => {
                            this.isShielded = false;
                            this.units.forEach(unit => unit.isShielded = false);
                        }, 3000);
                        this.skillCooldowns.shield = 300; // 5秒冷却
                        this.showMessage('护盾技能激活！');
                        break;

                    case 'boost':
                        // 加速技能：所有单位速度加倍
                        this.units.forEach(unit => {
                            unit.isBoosted = true;
                            unit.maxSpeed *= 2;
                        });
                        setTimeout(() => {
                            this.units.forEach(unit => {
                                unit.isBoosted = false;
                                unit.maxSpeed /= 2;
                            });
                        }, 2000);
                        this.skillCooldowns.boost = 240; // 4秒冷却
                        this.showMessage('加速技能激活！');
                        break;

                    case 'split':
                        // 分裂技能：单位分裂
                        if (this.units.length < 200) {
                            const newUnits = [];
                            this.units.forEach(unit => {
                                if (Math.random() < 0.5) {
                                    const newUnit = new Unit(unit.x + Math.random() * 20 - 10, unit.y + Math.random() * 20 - 10);
                                    newUnit.vx = unit.vx + (Math.random() - 0.5) * 4;
                                    newUnit.vy = unit.vy + (Math.random() - 0.5) * 4;
                                    newUnits.push(newUnit);
                                }
                            });
                            this.units.push(...newUnits);
                            this.params.count = this.units.length;
                            document.getElementById('countSlider').value = this.params.count;
                            document.getElementById('countDisplay').textContent = this.params.count;
                            this.skillCooldowns.split = 600; // 10秒冷却
                            this.showMessage(`分裂技能激活！单位数量：${this.units.length}`);
                        }
                        break;
                }

                this.updateUI();
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('level').textContent = this.level;
                document.getElementById('health').textContent = Math.max(0, Math.floor(this.health));
                document.getElementById('energy').textContent = Math.floor(this.energy);
            }

            showMessage(text) {
                const msg = document.createElement('div');
                msg.textContent = text;
                msg.style.cssText = `
                    position: fixed;
                    top: 100px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(79, 195, 247, 0.9);
                    color: white;
                    padding: 15px 30px;
                    border-radius: 10px;
                    font-size: 16px;
                    font-weight: bold;
                    z-index: 1000;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                `;
                document.body.appendChild(msg);

                setTimeout(() => {
                    document.body.removeChild(msg);
                }, 2000);
            }

            startGame() {
                this.gameState = 'playing';
                this.score = 0;
                this.level = 1;
                this.health = 100;
                this.energy = 100;
                this.createUnits(100);
                this.gameObjects = [];
                this.updateUI();
                this.showMessage('游戏开始！收集绿色食物，躲避红色敌人！');
            }

            pauseGame() {
                if (this.gameState === 'playing') {
                    this.gameState = 'paused';
                    this.showMessage('游戏暂停');
                } else if (this.gameState === 'paused') {
                    this.gameState = 'playing';
                    this.showMessage('游戏继续');
                }
            }

            resetGame() {
                this.gameState = 'menu';
                this.score = 0;
                this.level = 1;
                this.health = 100;
                this.energy = 100;
                this.createUnits(100);
                this.gameObjects = [];
                this.skillCooldowns = {
                    gather: 0,
                    shield: 0,
                    boost: 0,
                    split: 0
                };
                this.updateUI();
                this.showMessage('游戏已重置');
            }

            gameOver() {
                this.gameState = 'gameover';
                this.showMessage(`游戏结束！最终得分：${this.score}`);
            }

            setupEventListeners() {
                // 滑块事件
                document.getElementById('countSlider').addEventListener('input', (e) => {
                    this.params.count = parseInt(e.target.value);
                    document.getElementById('countDisplay').textContent = this.params.count;
                    this.createUnits(this.params.count);
                });

                document.getElementById('cohesionSlider').addEventListener('input', (e) => {
                    this.params.cohesionForce = parseFloat(e.target.value);
                    document.getElementById('cohesionDisplay').textContent = this.params.cohesionForce.toFixed(1);
                });

                document.getElementById('separationSlider').addEventListener('input', (e) => {
                    this.params.separationRadius = parseInt(e.target.value);
                    document.getElementById('separationDisplay').textContent = this.params.separationRadius;
                    this.params.separationForce = 1.0;
                });

                document.getElementById('alignmentSlider').addEventListener('input', (e) => {
                    this.params.alignmentForce = parseFloat(e.target.value);
                    document.getElementById('alignmentDisplay').textContent = this.params.alignmentForce.toFixed(1);
                });

                document.getElementById('speedSlider').addEventListener('input', (e) => {
                    this.params.maxSpeed = parseFloat(e.target.value);
                    document.getElementById('speedDisplay').textContent = this.params.maxSpeed.toFixed(1);
                });

                // 复选框事件
                document.getElementById('showTrails').addEventListener('change', (e) => {
                    this.params.showTrails = e.target.checked;
                });

                document.getElementById('showConnections').addEventListener('change', (e) => {
                    this.params.showConnections = e.target.checked;
                });

                document.getElementById('showInfluence').addEventListener('change', (e) => {
                    this.params.showInfluence = e.target.checked;
                });

                document.getElementById('showGrid').addEventListener('change', (e) => {
                    this.params.showGrid = e.target.checked;
                });

                document.getElementById('rainbowMode').addEventListener('change', (e) => {
                    this.params.rainbowMode = e.target.checked;
                });

                // 鼠标事件
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.targetX = e.clientX - rect.left;
                    this.targetY = e.clientY - rect.top;
                });

                // 键盘事件
                document.addEventListener('keydown', (e) => {
                    switch(e.key.toLowerCase()) {
                        case 'q':
                            this.useSkill('gather');
                            break;
                        case 'w':
                            this.useSkill('shield');
                            break;
                        case 'e':
                            this.useSkill('boost');
                            break;
                        case 'r':
                            this.useSkill('split');
                            break;
                        case ' ':
                            this.pauseGame();
                            break;
                    }
                });

                // 窗口大小调整
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                });
            }

            setMode(mode) {
                this.params.mode = mode;

                // 为不同模式调整参数
                switch (mode) {
                    case 'swarm':
                        this.params.cohesionForce = 2.0;
                        this.params.separationForce = 0.5;
                        this.params.alignmentForce = 0.5;
                        break;
                    case 'flee':
                        this.params.separationRadius = 100;
                        this.params.separationForce = 3.0;
                        break;
                    case 'orbit':
                        this.params.cohesionForce = 0.5;
                        this.params.alignmentForce = 0.2;
                        break;
                }

                this.updateSliders();
            }

            updateSliders() {
                document.getElementById('cohesionSlider').value = this.params.cohesionForce;
                document.getElementById('cohesionDisplay').textContent = this.params.cohesionForce.toFixed(1);
                document.getElementById('alignmentSlider').value = this.params.alignmentForce;
                document.getElementById('alignmentDisplay').textContent = this.params.alignmentForce.toFixed(1);
            }

            stressTest() {
                this.params.count = 5000;
                document.getElementById('countSlider').value = 5000;
                document.getElementById('countDisplay').textContent = '5000';
                this.createUnits(5000);
                this.showMessage('压力测试：5000个单位！');
            }

            benchmark() {
                const startTime = performance.now();
                const testDuration = 5000; // 5秒测试
                let frameCount = 0;

                const benchmark = () => {
                    frameCount++;
                    if (performance.now() - startTime < testDuration) {
                        requestAnimationFrame(benchmark);
                    } else {
                        const avgFps = frameCount / (testDuration / 1000);
                        this.showMessage(`基准测试完成：平均 ${avgFps.toFixed(1)} FPS`);
                    }
                };

                requestAnimationFrame(benchmark);
            }

            reset() {
                this.params = {
                    count: 1000,
                    cohesionForce: 1.0,
                    separationForce: 1.0,
                    alignmentForce: 1.0,
                    maxSpeed: 2.0,
                    separationRadius: 25,
                    alignmentRadius: 50,
                    cohesionRadius: 100,
                    neighborRadius: 100,
                    targetForce: 0.5,
                    mode: 'flock',
                    showTrails: true,
                    showConnections: true,
                    showInfluence: false,
                    showGrid: false,
                    rainbowMode: false,
                    time: 0
                };

                this.createUnits(1000);
                this.updateSliders();
                this.updateCheckboxes();
                this.showMessage('已重置为默认设置');
            }

            updateCheckboxes() {
                document.getElementById('showTrails').checked = this.params.showTrails;
                document.getElementById('showConnections').checked = this.params.showConnections;
                document.getElementById('showInfluence').checked = this.params.showInfluence;
                document.getElementById('showGrid').checked = this.params.showGrid;
                document.getElementById('rainbowMode').checked = this.params.rainbowMode;
            }

            showMessage(text) {
                // 创建临时消息
                const msg = document.createElement('div');
                msg.textContent = text;
                msg.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(79, 195, 247, 0.9);
                    color: white;
                    padding: 20px 40px;
                    border-radius: 10px;
                    font-size: 18px;
                    font-weight: bold;
                    z-index: 1000;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                `;
                document.body.appendChild(msg);

                setTimeout(() => {
                    document.body.removeChild(msg);
                }, 2000);
            }

            update() {
                // 更新时间
                this.params.time = Date.now();

                // 更新游戏逻辑
                this.updateGame();

                // 更新游戏对象
                for (let obj of this.gameObjects) {
                    obj.update();
                }

                // 更新所有单位
                for (let unit of this.units) {
                    unit.update(this.units, this.params, this.canvas.width, this.canvas.height, this.targetX, this.targetY);
                }

                // 检查碰撞
                this.checkCollisions();

                // 更新统计信息
                this.updateStats();
            }

            updateStats() {
                // 计算FPS
                this.frameCount++;
                const currentTime = performance.now();
                if (currentTime - this.lastTime >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastTime = currentTime;

                    // 更新显示
                    document.getElementById('unitCount').textContent = this.units.length;
                    document.getElementById('fps').textContent = this.fps;
                    document.getElementById('renderTime').textContent = this.renderTime.toFixed(1) + 'ms';

                    // 估算内存使用
                    const memoryUsage = (this.units.length * 100) / 1024 / 1024; // 粗略估算
                    document.getElementById('memory').textContent = memoryUsage.toFixed(1) + 'MB';
                }
            }

            draw() {
                const startTime = performance.now();

                // 清空画布
                if (this.gameState === 'menu') {
                    this.ctx.fillStyle = 'rgba(10, 10, 30, 1)';
                } else {
                    this.ctx.fillStyle = 'rgba(10, 10, 30, 0.1)';
                }
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // 绘制网格
                if (this.params.showGrid) {
                    this.drawGrid();
                }

                // 绘制游戏对象
                for (let obj of this.gameObjects) {
                    obj.draw(this.ctx);
                }

                // 绘制目标点
                this.drawTarget();

                // 绘制连接线
                if (this.params.showConnections) {
                    this.drawConnections();
                }

                // 绘制影响范围
                if (this.params.showInfluence) {
                    this.drawInfluence();
                }

                // 绘制所有单位
                for (let unit of this.units) {
                    unit.draw(this.ctx, this.params);
                }

                // 绘制游戏状态
                if (this.gameState === 'menu') {
                    this.drawMenuScreen();
                } else if (this.gameState === 'paused') {
                    this.drawPausedScreen();
                } else if (this.gameState === 'gameover') {
                    this.drawGameOverScreen();
                }

                this.renderTime = performance.now() - startTime;
            }

            drawMenuScreen() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.fillStyle = '#fff';
                this.ctx.font = 'bold 48px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('集体智慧', this.canvas.width / 2, this.canvas.height / 2 - 50);

                this.ctx.font = '24px Arial';
                this.ctx.fillText('点击"开始游戏"开始冒险', this.canvas.width / 2, this.canvas.height / 2 + 20);

                this.ctx.font = '16px Arial';
                this.ctx.fillStyle = '#aaa';
                this.ctx.fillText('移动鼠标控制群体 • Q/W/E/R使用技能', this.canvas.width / 2, this.canvas.height / 2 + 60);
            }

            drawPausedScreen() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.fillStyle = '#fff';
                this.ctx.font = 'bold 36px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('游戏暂停', this.canvas.width / 2, this.canvas.height / 2);
            }

            drawGameOverScreen() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.fillStyle = '#f44336';
                this.ctx.font = 'bold 48px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('游戏结束', this.canvas.width / 2, this.canvas.height / 2 - 50);

                this.ctx.fillStyle = '#fff';
                this.ctx.font = '24px Arial';
                this.ctx.fillText(`最终得分：${this.score}`, this.canvas.width / 2, this.canvas.height / 2 + 20);
            }

            drawGrid() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                this.ctx.lineWidth = 1;

                const gridSize = 50;
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }

                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }

            drawTarget() {
                // 绘制目标点
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.beginPath();
                this.ctx.arc(this.targetX, this.targetY, 8, 0, Math.PI * 2);
                this.ctx.fill();

                // 绘制脉冲效果
                const pulse = Math.sin(Date.now() * 0.005) * 0.5 + 0.5;
                this.ctx.strokeStyle = `rgba(255, 255, 255, ${pulse * 0.3})`;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(this.targetX, this.targetY, 20 + pulse * 10, 0, Math.PI * 2);
                this.ctx.stroke();
            }

            drawConnections() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 0.5;

                // 只绘制部分连接以避免性能问题
                const maxConnections = Math.min(500, this.units.length * 2);
                let connections = 0;

                for (let i = 0; i < this.units.length && connections < maxConnections; i++) {
                    const unit = this.units[i];
                    for (let neighbor of unit.neighbors.slice(0, 3)) {
                        if (connections >= maxConnections) break;

                        this.ctx.beginPath();
                        this.ctx.moveTo(unit.x, unit.y);
                        this.ctx.lineTo(neighbor.boid.x, neighbor.boid.y);
                        this.ctx.stroke();
                        connections++;
                    }
                }
            }

            drawInfluence() {
                // 绘制目标点的影响范围
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                this.ctx.beginPath();
                this.ctx.arc(this.targetX, this.targetY, 100, 0, Math.PI * 2);
                this.ctx.fill();
            }

            gameLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // 启动游戏
        const game = new CollectiveMindGame();
    </script>
</body>
</html>