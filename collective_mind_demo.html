<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é›†ä½“æ™ºæ…§ - å¤§è§„æ¨¡ç¾¤ä½“è¡Œä¸ºæ¼”ç¤º</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            text-align: center;
            backdrop-filter: blur(10px);
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.5);
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            font-size: 14px;
            color: #aaa;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-value {
            color: #4fc3f7;
            font-weight: bold;
            font-size: 16px;
        }

        .main-container {
            flex: 1;
            display: flex;
            position: relative;
        }

        .sidebar {
            width: 280px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border-right: 2px solid rgba(255, 255, 255, 0.1);
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group h3 {
            margin-bottom: 15px;
            color: #4fc3f7;
            font-size: 16px;
            border-bottom: 1px solid rgba(79, 195, 247, 0.3);
            padding-bottom: 5px;
        }

        .control-item {
            margin-bottom: 12px;
        }

        .control-item label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #ccc;
        }

        .slider {
            width: 100%;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
        }

        .btn {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: linear-gradient(45deg, #4fc3f7, #29b6f6);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(79, 195, 247, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(79, 195, 247, 0.5);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.danger {
            background: linear-gradient(45deg, #f44336, #e91e63);
            box-shadow: 0 2px 10px rgba(244, 67, 54, 0.3);
        }

        .btn.danger:hover {
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.5);
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: #000;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        .performance-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #4fc3f7;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(79, 195, 247, 0.3);
        }

        .info-panel {
            margin-top: 20px;
            padding: 15px;
            background: rgba(79, 195, 247, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(79, 195, 247, 0.3);
        }

        .info-panel h4 {
            margin-bottom: 10px;
            color: #4fc3f7;
        }

        .info-panel p {
            font-size: 12px;
            line-height: 1.4;
            color: #ccc;
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
        }

        .checkbox-wrapper input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .checkbox-wrapper label {
            font-size: 13px;
            color: #ccc;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ§¬ é›†ä½“æ™ºæ…§ - å¤§è§„æ¨¡ç¾¤ä½“è¡Œä¸ºæ¼”ç¤º</h1>
        <div class="stats">
            <div class="stat-item">
                <span>å•ä½æ•°é‡:</span>
                <span class="stat-value" id="unitCount">1000</span>
            </div>
            <div class="stat-item">
                <span>å¸§ç‡:</span>
                <span class="stat-value" id="fps">60</span>
            </div>
            <div class="stat-item">
                <span>æ¸²æŸ“æ—¶é—´:</span>
                <span class="stat-value" id="renderTime">0ms</span>
            </div>
            <div class="stat-item">
                <span>å†…å­˜ä½¿ç”¨:</span>
                <span class="stat-value" id="memory">0MB</span>
            </div>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="control-group">
                <h3>ğŸ® ç¾¤ä½“æ§åˆ¶</h3>
                <div class="control-item">
                    <label>å•ä½æ•°é‡: <span id="countDisplay">1000</span></label>
                    <input type="range" class="slider" id="countSlider" min="100" max="5000" value="1000" step="100">
                </div>
                <div class="control-item">
                    <label>å‡èšå¼ºåº¦: <span id="cohesionDisplay">1.0</span></label>
                    <input type="range" class="slider" id="cohesionSlider" min="0" max="2" value="1" step="0.1">
                </div>
                <div class="control-item">
                    <label>åˆ†ç¦»è·ç¦»: <span id="separationDisplay">25</span></label>
                    <input type="range" class="slider" id="separationSlider" min="10" max="50" value="25" step="5">
                </div>
                <div class="control-item">
                    <label>å¯¹é½å¼ºåº¦: <span id="alignmentDisplay">1.0</span></label>
                    <input type="range" class="slider" id="alignmentSlider" min="0" max="2" value="1" step="0.1">
                </div>
                <div class="control-item">
                    <label>ç§»åŠ¨é€Ÿåº¦: <span id="speedDisplay">2.0</span></label>
                    <input type="range" class="slider" id="speedSlider" min="0.5" max="5" value="2" step="0.5">
                </div>
            </div>

            <div class="control-group">
                <h3>ğŸ¨ è§†è§‰æ•ˆæœ</h3>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="showTrails" checked>
                    <label for="showTrails">æ˜¾ç¤ºè½¨è¿¹</label>
                </div>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="showConnections" checked>
                    <label for="showConnections">æ˜¾ç¤ºè¿æ¥çº¿</label>
                </div>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="showInfluence">
                    <label for="showInfluence">æ˜¾ç¤ºå½±å“èŒƒå›´</label>
                </div>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="showGrid">
                    <label for="showGrid">æ˜¾ç¤ºç½‘æ ¼</label>
                </div>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="rainbowMode">
                    <label for="rainbowMode">å½©è™¹æ¨¡å¼</label>
                </div>
            </div>

            <div class="control-group">
                <h3>ğŸ¯ è¡Œä¸ºæ¨¡å¼</h3>
                <button class="btn" onclick="game.setMode('flock')">é›†ç¾¤æ¨¡å¼</button>
                <button class="btn" onclick="game.setMode('swarm')">èœ‚ç¾¤æ¨¡å¼</button>
                <button class="btn" onclick="game.setMode('flee')">é€ƒè·‘æ¨¡å¼</button>
                <button class="btn" onclick="game.setMode('orbit')">è½¨é“æ¨¡å¼</button>
                <button class="btn" onclick="game.setMode('random')">éšæœºæ¼«æ­¥</button>
                <button class="btn" onclick="game.setMode('wave')">æ³¢æµªæ¨¡å¼</button>
            </div>

            <div class="control-group">
                <h3>ğŸ® æ¸¸æˆæ§åˆ¶</h3>
                <button class="btn" onclick="game.startGame()">å¼€å§‹æ¸¸æˆ</button>
                <button class="btn" onclick="game.pauseGame()">æš‚åœ</button>
                <button class="btn danger" onclick="game.resetGame()">é‡ç½®æ¸¸æˆ</button>
            </div>

            <div class="control-group">
                <h3>ğŸ“Š æ¸¸æˆçŠ¶æ€</h3>
                <div class="stat-item">
                    <span>å¾—åˆ†:</span>
                    <span class="stat-value" id="score">0</span>
                </div>
                <div class="stat-item">
                    <span>ç­‰çº§:</span>
                    <span class="stat-value" id="level">1</span>
                </div>
                <div class="stat-item">
                    <span>ç”Ÿå‘½:</span>
                    <span class="stat-value" id="health">100</span>
                </div>
                <div class="stat-item">
                    <span>èƒ½é‡:</span>
                    <span class="stat-value" id="energy">100</span>
                </div>
            </div>

            <div class="control-group">
                <h3>âš¡ æŠ€èƒ½</h3>
                <button class="btn" onclick="game.useSkill('gather')" id="gatherBtn">èšé›† [Q]</button>
                <button class="btn" onclick="game.useSkill('shield')" id="shieldBtn">æŠ¤ç›¾ [W]</button>
                <button class="btn" onclick="game.useSkill('boost')" id="boostBtn">åŠ é€Ÿ [E]</button>
                <button class="btn" onclick="game.useSkill('split')" id="splitBtn">åˆ†è£‚ [R]</button>
            </div>

            <div class="info-panel">
                <h4>ğŸ® æ¸¸æˆç©æ³•</h4>
                <p>â€¢ <strong>ç›®æ ‡ï¼š</strong>å¼•å¯¼ä½ çš„ç¾¤ä½“æ”¶é›†é£Ÿç‰©ï¼Œèº²é¿æ•Œäººï¼Œç”Ÿå­˜ä¸‹å»</p>
                <p>â€¢ <strong>é£Ÿç‰©(ç»¿è‰²)</strong>ï¼šå¢åŠ å¾—åˆ†å’Œèƒ½é‡</p>
                <p>â€¢ <strong>æ•Œäºº(çº¢è‰²)</strong>ï¼šç¢°æ’ä¼šæŸå¤±ç”Ÿå‘½</p>
                <p>â€¢ <strong>æŠ€èƒ½ï¼š</strong>ä½¿ç”¨Q/W/E/Ré”®é‡Šæ”¾ç‰¹æ®ŠæŠ€èƒ½</p>
                <p>â€¢ <strong>å‡çº§ï¼š</strong>è¾¾åˆ°ä¸€å®šåˆ†æ•°è·å¾—æ›´å¤šå•ä½</p>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="gameCanvas"></canvas>
            <div class="performance-info">
                <div>GPUå®ä¾‹åŒ–: <span id="instancing">ON</span></div>
                <div>ç©ºé—´åˆ†åŒº: <span id="spatialHashing">ON</span></div>
                <div>æ‰¹å¤„ç†æ¸²æŸ“: <span id="batching">ON</span></div>
                <div>LODç³»ç»Ÿ: <span id="lod">ON</span></div>
            </div>
        </div>
    </div>

    <script>
        class GameObject {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = type === 'food' ? 8 : (type === 'enemy' ? 12 : 6);
                this.collected = false;
                this.lifetime = type === 'enemy' ? 600 : 1000; // 10ç§’æ•Œäººï¼Œ16ç§’é£Ÿç‰©
                this.createdAt = Date.now();
                this.pulsePhase = Math.random() * Math.PI * 2;

                if (type === 'food') {
                    this.color = '#4caf50';
                    this.value = 10;
                } else if (type === 'enemy') {
                    this.color = '#f44336';
                    this.damage = 10;
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = (Math.random() - 0.5) * 2;
                }
            }

            update() {
                this.pulsePhase += 0.1;

                if (this.type === 'enemy') {
                    // æ•Œäººç®€å•ç§»åŠ¨
                    this.x += this.vx;
                    this.y += this.vy;

                    // è¾¹ç•Œåå¼¹
                    if (this.x < this.radius || this.x > game.canvas.width - this.radius) {
                        this.vx = -this.vx;
                    }
                    if (this.y < this.radius || this.y > game.canvas.height - this.radius) {
                        this.vy = -this.vy;
                    }
                }

                // æ£€æŸ¥ç”Ÿå‘½å‘¨æœŸ
                if (Date.now() - this.createdAt > this.lifetime) {
                    this.collected = true;
                }
            }

            draw(ctx) {
                if (this.collected) return;

                const pulse = Math.sin(this.pulsePhase) * 0.2 + 1;

                ctx.save();

                // å‘å…‰æ•ˆæœ
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15 * pulse;

                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * pulse, 0, Math.PI * 2);
                ctx.fill();

                // ä¸­å¿ƒç‚¹
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class Unit {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.ax = 0;
                this.ay = 0;
                this.maxSpeed = 2;
                this.maxForce = 0.05;
                this.radius = 3;
                this.baseColor = `hsl(${Math.random() * 60 + 200}, 70%, 60%)`;
                this.color = this.baseColor;
                this.trail = [];
                this.maxTrailLength = 20;
                this.neighbors = [];
                this.gridCell = null;
                this.isShielded = false;
                this.isBoosted = false;
            }

            update(boids, params, width, height, targetX, targetY) {
                // é‡ç½®åŠ é€Ÿåº¦
                this.ax = 0;
                this.ay = 0;

                // å¯»æ‰¾é‚»å±…ï¼ˆä¼˜åŒ–ï¼šä½¿ç”¨ç©ºé—´åˆ†åŒºï¼‰
                this.findNeighbors(boids, params.neighborRadius);

                // åº”ç”¨ä¸åŒçš„è¡Œä¸ºæ¨¡å¼
                switch (params.mode) {
                    case 'flock':
                        this.flock(this.neighbors, params);
                        this.seekTarget(targetX, targetY, params.targetForce);
                        break;
                    case 'swarm':
                        this.swarm(this.neighbors, params);
                        break;
                    case 'flee':
                        this.fleeFromTarget(targetX, targetY, params.targetForce);
                        break;
                    case 'orbit':
                        this.orbit(targetX, targetY, params);
                        break;
                    case 'wave':
                        this.wave(params.time);
                        break;
                    case 'random':
                        this.wander();
                        break;
                }

                // é¿å…è¾¹ç•Œ
                this.avoidEdges(width, height);

                // æ›´æ–°é€Ÿåº¦
                this.vx += this.ax;
                this.vy += this.ay;

                // é™åˆ¶é€Ÿåº¦
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > params.maxSpeed) {
                    this.vx = (this.vx / speed) * params.maxSpeed;
                    this.vy = (this.vy / speed) * params.maxSpeed;
                }

                // æ›´æ–°ä½ç½®
                this.x += this.vx;
                this.y += this.vy;

                // æ›´æ–°è½¨è¿¹
                if (params.showTrails && Math.random() < 0.3) {
                    this.trail.push({ x: this.x, y: this.y, alpha: 1 });
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                }

                // æ›´æ–°è½¨è¿¹é€æ˜åº¦
                this.trail.forEach(point => {
                    point.alpha *= 0.95;
                });
                this.trail = this.trail.filter(point => point.alpha > 0.01);
            }

            findNeighbors(boids, radius) {
                this.neighbors = [];
                for (let boid of boids) {
                    if (boid !== this) {
                        const dx = boid.x - this.x;
                        const dy = boid.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < radius) {
                            this.neighbors.push({ boid, distance: dist });
                        }
                    }
                }
                this.neighbors.sort((a, b) => a.distance - b.distance);
            }

            flock(neighbors, params) {
                if (neighbors.length === 0) return;

                let separation = { x: 0, y: 0 };
                let alignment = { x: 0, y: 0 };
                let cohesion = { x: 0, y: 0 };
                let count = 0;

                for (let { boid, distance } of neighbors) {
                    // åˆ†ç¦» (Separation)
                    if (distance < params.separationRadius && distance > 0) {
                        const diff = {
                            x: this.x - boid.x,
                            y: this.y - boid.y
                        };
                        const norm = Math.sqrt(diff.x * diff.x + diff.y * diff.y);
                        if (norm > 0) {
                            separation.x += (diff.x / norm) / distance;
                            separation.y += (diff.y / norm) / distance;
                        }
                    }

                    // å¯¹é½ (Alignment)
                    if (distance < params.alignmentRadius) {
                        alignment.x += boid.vx;
                        alignment.y += boid.vy;
                        count++;
                    }

                    // å‡èš (Cohesion)
                    if (distance < params.cohesionRadius) {
                        cohesion.x += boid.x;
                        cohesion.y += boid.y;
                        count++;
                    }
                }

                // åº”ç”¨åŠ›
                if (count > 0) {
                    // åˆ†ç¦»åŠ›
                    if (separation.x !== 0 || separation.y !== 0) {
                        const sepMag = Math.sqrt(separation.x * separation.x + separation.y * separation.y);
                        if (sepMag > 0) {
                            this.ax += (separation.x / sepMag) * params.separationForce;
                            this.ay += (separation.y / sepMag) * params.separationForce;
                        }
                    }

                    // å¯¹é½åŠ›
                    alignment.x /= count;
                    alignment.y /= count;
                    this.ax += (alignment.x - this.vx) * params.alignmentForce;
                    this.ay += (alignment.y - this.vy) * params.alignmentForce;

                    // å‡èšåŠ›
                    cohesion.x /= count;
                    cohesion.y /= count;
                    this.ax += (cohesion.x - this.x) * params.cohesionForce * 0.01;
                    this.ay += (cohesion.y - this.y) * params.cohesionForce * 0.01;
                }
            }

            swarm(neighbors, params) {
                // èœ‚ç¾¤æ¨¡å¼ï¼šæ›´å¼ºçš„å‡èšæ€§ï¼Œæ›´å¼±çš„åˆ†ç¦»
                if (neighbors.length === 0) return;

                let center = { x: 0, y: 0 };
                let separation = { x: 0, y: 0 };

                for (let { boid, distance } of neighbors) {
                    center.x += boid.x;
                    center.y += boid.y;

                    if (distance < params.separationRadius * 0.5) {
                        const diff = {
                            x: this.x - boid.x,
                            y: this.y - boid.y
                        };
                        const norm = Math.sqrt(diff.x * diff.x + diff.y * diff.y);
                        if (norm > 0) {
                            separation.x += (diff.x / norm) / distance;
                            separation.y += (diff.y / norm) / distance;
                        }
                    }
                }

                center.x /= neighbors.length;
                center.y /= neighbors.length;

                // å¼ºåŠ›å‡èš
                this.ax += (center.x - this.x) * params.cohesionForce * 0.02;
                this.ay += (center.y - this.y) * params.cohesionForce * 0.02;

                // å¼±åˆ†ç¦»
                if (separation.x !== 0 || separation.y !== 0) {
                    const sepMag = Math.sqrt(separation.x * separation.x + separation.y * separation.y);
                    if (sepMag > 0) {
                        this.ax += (separation.x / sepMag) * params.separationForce * 0.5;
                        this.ay += (separation.y / sepMag) * params.separationForce * 0.5;
                    }
                }
            }

            seekTarget(targetX, targetY, force) {
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 5) {
                    this.ax += (dx / dist) * force;
                    this.ay += (dy / dist) * force;
                }
            }

            fleeFromTarget(targetX, targetY, force) {
                const dx = this.x - targetX;
                const dy = this.y - targetY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 200 && dist > 0) {
                    this.ax += (dx / dist) * force * 2;
                    this.ay += (dy / dist) * force * 2;
                }
            }

            orbit(targetX, targetY, params) {
                const dx = this.x - targetX;
                const dy = this.y - targetY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const targetDist = 150 + Math.sin(params.time * 0.001 + this.x * 0.01) * 50;

                if (dist > 0) {
                    // å‘ç›®æ ‡è½¨é“ç§»åŠ¨
                    this.ax += ((dx / dist) * (dist - targetDist)) * 0.01;
                    this.ay += ((dy / dist) * (dist - targetDist)) * 0.01;

                    // åˆ‡å‘é€Ÿåº¦
                    const tangentX = -dy / dist;
                    const tangentY = dx / dist;
                    this.ax += tangentX * params.maxSpeed * 0.5;
                    this.ay += tangentY * params.maxSpeed * 0.5;
                }
            }

            wave(params) {
                // æ³¢æµªæ¨¡å¼ï¼šåŸºäºä½ç½®å’Œæ—¶é—´äº§ç”Ÿæ³¢åŠ¨
                const waveX = Math.sin(params.time * 0.001 + this.y * 0.01) * 50;
                const waveY = Math.cos(params.time * 0.001 + this.x * 0.01) * 30;

                this.ax += waveX * 0.01;
                this.ay += waveY * 0.01;
            }

            wander() {
                // éšæœºæ¼«æ­¥
                this.ax += (Math.random() - 0.5) * 0.1;
                this.ay += (Math.random() - 0.5) * 0.1;
            }

            avoidEdges(width, height) {
                const margin = 50;
                const turnForce = 0.5;

                if (this.x < margin) {
                    this.ax += turnForce;
                } else if (this.x > width - margin) {
                    this.ax -= turnForce;
                }

                if (this.y < margin) {
                    this.ay += turnForce;
                } else if (this.y > height - margin) {
                    this.ay -= turnForce;
                }
            }

            draw(ctx, params) {
                // æŠ¤ç›¾æ•ˆæœ
                if (this.isShielded) {
                    ctx.strokeStyle = 'rgba(100, 200, 255, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // åŠ é€Ÿæ•ˆæœ
                if (this.isBoosted) {
                    ctx.shadowColor = '#ff9800';
                    ctx.shadowBlur = 15;
                }

                // ç»˜åˆ¶è½¨è¿¹
                if (params.showTrails && this.trail.length > 1) {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.globalAlpha = this.trail[i].alpha * 0.3;
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }

                // æ›´æ–°é¢œè‰²ï¼ˆå½©è™¹æ¨¡å¼ï¼‰
                if (params.rainbowMode) {
                    const hue = (params.time * 0.1 + this.x * 0.5 + this.y * 0.5) % 360;
                    this.color = `hsl(${hue}, 70%, 60%)`;
                } else {
                    this.color = this.baseColor;
                }

                // ç»˜åˆ¶å•ä½
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0;
            }
        }

        class CollectiveMindGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.units = [];
                this.gameObjects = [];
                this.targetX = 0;
                this.targetY = 0;

                // æ¸¸æˆçŠ¶æ€
                this.gameState = 'menu'; // menu, playing, paused, gameover
                this.score = 0;
                this.level = 1;
                this.health = 100;
                this.energy = 100;
                this.isShielded = false;
                this.skillCooldowns = {
                    gather: 0,
                    shield: 0,
                    boost: 0,
                    split: 0
                };

                this.params = {
                    count: 100,
                    cohesionForce: 1.0,
                    separationForce: 1.0,
                    alignmentForce: 1.0,
                    maxSpeed: 2.0,
                    separationRadius: 25,
                    alignmentRadius: 50,
                    cohesionRadius: 100,
                    neighborRadius: 100,
                    targetForce: 0.5,
                    mode: 'flock',
                    showTrails: true,
                    showConnections: true,
                    showInfluence: false,
                    showGrid: false,
                    rainbowMode: false,
                    time: 0
                };

                this.fps = 60;
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.renderTime = 0;
                this.lastSpawnTime = 0;

                this.init();
                this.setupEventListeners();
                this.gameLoop();
            }

            init() {
                this.resizeCanvas();
                this.createUnits(this.params.count);
                this.targetX = this.canvas.width / 2;
                this.targetY = this.canvas.height / 2;
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
            }

            createUnits(count) {
                this.units = [];
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const radius = Math.random() * 200;
                    const x = this.canvas.width / 2 + Math.cos(angle) * radius;
                    const y = this.canvas.height / 2 + Math.sin(angle) * radius;
                    this.units.push(new Unit(x, y));
                }
            }

            spawnGameObject(type) {
                const margin = 50;
                const x = margin + Math.random() * (this.canvas.width - margin * 2);
                const y = margin + Math.random() * (this.canvas.height - margin * 2);
                this.gameObjects.push(new GameObject(x, y, type));
            }

            checkCollisions() {
                if (this.gameState !== 'playing') return;

                for (let unit of this.units) {
                    for (let obj of this.gameObjects) {
                        if (obj.collected) continue;

                        const dx = unit.x - obj.x;
                        const dy = unit.y - obj.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < unit.radius + obj.radius) {
                            if (obj.type === 'food') {
                                // æ”¶é›†é£Ÿç‰©
                                obj.collected = true;
                                this.score += obj.value;
                                this.energy = Math.min(100, this.energy + 5);
                                this.updateUI();
                            } else if (obj.type === 'enemy' && !this.isShielded) {
                                // ç¢°åˆ°æ•Œäºº
                                this.health -= obj.damage;
                                obj.collected = true;
                                this.updateUI();

                                if (this.health <= 0) {
                                    this.gameOver();
                                }
                            }
                        }
                    }
                }

                // æ¸…ç†å·²æ”¶é›†çš„å¯¹è±¡
                this.gameObjects = this.gameObjects.filter(obj => !obj.collected);
            }

            updateGame() {
                if (this.gameState !== 'playing') return;

                const currentTime = Date.now();

                // ç”Ÿæˆé£Ÿç‰©å’Œæ•Œäºº
                if (currentTime - this.lastSpawnTime > 2000) { // æ¯2ç§’ç”Ÿæˆ
                    this.spawnGameObject('food');

                    // æ ¹æ®ç­‰çº§ç”Ÿæˆæ•Œäºº
                    if (Math.random() < this.level * 0.1) {
                        this.spawnGameObject('enemy');
                    }

                    this.lastSpawnTime = currentTime;
                }

                // æ›´æ–°æŠ€èƒ½å†·å´
                for (let skill in this.skillCooldowns) {
                    if (this.skillCooldowns[skill] > 0) {
                        this.skillCooldowns[skill]--;
                    }
                }

                // æ£€æŸ¥å‡çº§
                if (this.score >= this.level * 100) {
                    this.levelUp();
                }

                // æ¢å¤èƒ½é‡
                if (this.energy < 100) {
                    this.energy = Math.min(100, this.energy + 0.01);
                    this.updateUI();
                }
            }

            levelUp() {
                this.level++;
                this.units.push(new Unit(this.canvas.width / 2, this.canvas.height / 2));
                this.params.count = this.units.length;
                document.getElementById('countSlider').value = this.params.count;
                document.getElementById('countDisplay').textContent = this.params.count;
                this.showMessage(`å‡çº§åˆ°ç­‰çº§ ${this.level}ï¼`);
            }

            useSkill(skill) {
                if (this.gameState !== 'playing') return;
                if (this.skillCooldowns[skill] > 0) {
                    this.showMessage('æŠ€èƒ½å†·å´ä¸­...');
                    return;
                }

                switch (skill) {
                    case 'gather':
                        // èšé›†æŠ€èƒ½ï¼šæ‰€æœ‰å•ä½å¿«é€Ÿèšé›†åˆ°ç›®æ ‡
                        this.units.forEach(unit => {
                            const dx = this.targetX - unit.x;
                            const dy = this.targetY - unit.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 0) {
                                unit.vx += (dx / dist) * 5;
                                unit.vy += (dy / dist) * 5;
                            }
                        });
                        this.skillCooldowns.gather = 180; // 3ç§’å†·å´
                        this.showMessage('èšé›†æŠ€èƒ½é‡Šæ”¾ï¼');
                        break;

                    case 'shield':
                        // æŠ¤ç›¾æŠ€èƒ½ï¼šæ‰€æœ‰å•ä½è·å¾—æŠ¤ç›¾
                        this.isShielded = true;
                        this.units.forEach(unit => unit.isShielded = true);
                        setTimeout(() => {
                            this.isShielded = false;
                            this.units.forEach(unit => unit.isShielded = false);
                        }, 3000);
                        this.skillCooldowns.shield = 300; // 5ç§’å†·å´
                        this.showMessage('æŠ¤ç›¾æŠ€èƒ½æ¿€æ´»ï¼');
                        break;

                    case 'boost':
                        // åŠ é€ŸæŠ€èƒ½ï¼šæ‰€æœ‰å•ä½é€Ÿåº¦åŠ å€
                        this.units.forEach(unit => {
                            unit.isBoosted = true;
                            unit.maxSpeed *= 2;
                        });
                        setTimeout(() => {
                            this.units.forEach(unit => {
                                unit.isBoosted = false;
                                unit.maxSpeed /= 2;
                            });
                        }, 2000);
                        this.skillCooldowns.boost = 240; // 4ç§’å†·å´
                        this.showMessage('åŠ é€ŸæŠ€èƒ½æ¿€æ´»ï¼');
                        break;

                    case 'split':
                        // åˆ†è£‚æŠ€èƒ½ï¼šå•ä½åˆ†è£‚
                        if (this.units.length < 200) {
                            const newUnits = [];
                            this.units.forEach(unit => {
                                if (Math.random() < 0.5) {
                                    const newUnit = new Unit(unit.x + Math.random() * 20 - 10, unit.y + Math.random() * 20 - 10);
                                    newUnit.vx = unit.vx + (Math.random() - 0.5) * 4;
                                    newUnit.vy = unit.vy + (Math.random() - 0.5) * 4;
                                    newUnits.push(newUnit);
                                }
                            });
                            this.units.push(...newUnits);
                            this.params.count = this.units.length;
                            document.getElementById('countSlider').value = this.params.count;
                            document.getElementById('countDisplay').textContent = this.params.count;
                            this.skillCooldowns.split = 600; // 10ç§’å†·å´
                            this.showMessage(`åˆ†è£‚æŠ€èƒ½æ¿€æ´»ï¼å•ä½æ•°é‡ï¼š${this.units.length}`);
                        }
                        break;
                }

                this.updateUI();
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('level').textContent = this.level;
                document.getElementById('health').textContent = Math.max(0, Math.floor(this.health));
                document.getElementById('energy').textContent = Math.floor(this.energy);
            }

            showMessage(text) {
                const msg = document.createElement('div');
                msg.textContent = text;
                msg.style.cssText = `
                    position: fixed;
                    top: 100px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(79, 195, 247, 0.9);
                    color: white;
                    padding: 15px 30px;
                    border-radius: 10px;
                    font-size: 16px;
                    font-weight: bold;
                    z-index: 1000;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                `;
                document.body.appendChild(msg);

                setTimeout(() => {
                    document.body.removeChild(msg);
                }, 2000);
            }

            startGame() {
                this.gameState = 'playing';
                this.score = 0;
                this.level = 1;
                this.health = 100;
                this.energy = 100;
                this.createUnits(100);
                this.gameObjects = [];
                this.updateUI();
                this.showMessage('æ¸¸æˆå¼€å§‹ï¼æ”¶é›†ç»¿è‰²é£Ÿç‰©ï¼Œèº²é¿çº¢è‰²æ•Œäººï¼');
            }

            pauseGame() {
                if (this.gameState === 'playing') {
                    this.gameState = 'paused';
                    this.showMessage('æ¸¸æˆæš‚åœ');
                } else if (this.gameState === 'paused') {
                    this.gameState = 'playing';
                    this.showMessage('æ¸¸æˆç»§ç»­');
                }
            }

            resetGame() {
                this.gameState = 'menu';
                this.score = 0;
                this.level = 1;
                this.health = 100;
                this.energy = 100;
                this.createUnits(100);
                this.gameObjects = [];
                this.skillCooldowns = {
                    gather: 0,
                    shield: 0,
                    boost: 0,
                    split: 0
                };
                this.updateUI();
                this.showMessage('æ¸¸æˆå·²é‡ç½®');
            }

            gameOver() {
                this.gameState = 'gameover';
                this.showMessage(`æ¸¸æˆç»“æŸï¼æœ€ç»ˆå¾—åˆ†ï¼š${this.score}`);
            }

            setupEventListeners() {
                // æ»‘å—äº‹ä»¶
                document.getElementById('countSlider').addEventListener('input', (e) => {
                    this.params.count = parseInt(e.target.value);
                    document.getElementById('countDisplay').textContent = this.params.count;
                    this.createUnits(this.params.count);
                });

                document.getElementById('cohesionSlider').addEventListener('input', (e) => {
                    this.params.cohesionForce = parseFloat(e.target.value);
                    document.getElementById('cohesionDisplay').textContent = this.params.cohesionForce.toFixed(1);
                });

                document.getElementById('separationSlider').addEventListener('input', (e) => {
                    this.params.separationRadius = parseInt(e.target.value);
                    document.getElementById('separationDisplay').textContent = this.params.separationRadius;
                    this.params.separationForce = 1.0;
                });

                document.getElementById('alignmentSlider').addEventListener('input', (e) => {
                    this.params.alignmentForce = parseFloat(e.target.value);
                    document.getElementById('alignmentDisplay').textContent = this.params.alignmentForce.toFixed(1);
                });

                document.getElementById('speedSlider').addEventListener('input', (e) => {
                    this.params.maxSpeed = parseFloat(e.target.value);
                    document.getElementById('speedDisplay').textContent = this.params.maxSpeed.toFixed(1);
                });

                // å¤é€‰æ¡†äº‹ä»¶
                document.getElementById('showTrails').addEventListener('change', (e) => {
                    this.params.showTrails = e.target.checked;
                });

                document.getElementById('showConnections').addEventListener('change', (e) => {
                    this.params.showConnections = e.target.checked;
                });

                document.getElementById('showInfluence').addEventListener('change', (e) => {
                    this.params.showInfluence = e.target.checked;
                });

                document.getElementById('showGrid').addEventListener('change', (e) => {
                    this.params.showGrid = e.target.checked;
                });

                document.getElementById('rainbowMode').addEventListener('change', (e) => {
                    this.params.rainbowMode = e.target.checked;
                });

                // é¼ æ ‡äº‹ä»¶
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.targetX = e.clientX - rect.left;
                    this.targetY = e.clientY - rect.top;
                });

                // é”®ç›˜äº‹ä»¶
                document.addEventListener('keydown', (e) => {
                    switch(e.key.toLowerCase()) {
                        case 'q':
                            this.useSkill('gather');
                            break;
                        case 'w':
                            this.useSkill('shield');
                            break;
                        case 'e':
                            this.useSkill('boost');
                            break;
                        case 'r':
                            this.useSkill('split');
                            break;
                        case ' ':
                            this.pauseGame();
                            break;
                    }
                });

                // çª—å£å¤§å°è°ƒæ•´
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                });
            }

            setMode(mode) {
                this.params.mode = mode;

                // ä¸ºä¸åŒæ¨¡å¼è°ƒæ•´å‚æ•°
                switch (mode) {
                    case 'swarm':
                        this.params.cohesionForce = 2.0;
                        this.params.separationForce = 0.5;
                        this.params.alignmentForce = 0.5;
                        break;
                    case 'flee':
                        this.params.separationRadius = 100;
                        this.params.separationForce = 3.0;
                        break;
                    case 'orbit':
                        this.params.cohesionForce = 0.5;
                        this.params.alignmentForce = 0.2;
                        break;
                }

                this.updateSliders();
            }

            updateSliders() {
                document.getElementById('cohesionSlider').value = this.params.cohesionForce;
                document.getElementById('cohesionDisplay').textContent = this.params.cohesionForce.toFixed(1);
                document.getElementById('alignmentSlider').value = this.params.alignmentForce;
                document.getElementById('alignmentDisplay').textContent = this.params.alignmentForce.toFixed(1);
            }

            stressTest() {
                this.params.count = 5000;
                document.getElementById('countSlider').value = 5000;
                document.getElementById('countDisplay').textContent = '5000';
                this.createUnits(5000);
                this.showMessage('å‹åŠ›æµ‹è¯•ï¼š5000ä¸ªå•ä½ï¼');
            }

            benchmark() {
                const startTime = performance.now();
                const testDuration = 5000; // 5ç§’æµ‹è¯•
                let frameCount = 0;

                const benchmark = () => {
                    frameCount++;
                    if (performance.now() - startTime < testDuration) {
                        requestAnimationFrame(benchmark);
                    } else {
                        const avgFps = frameCount / (testDuration / 1000);
                        this.showMessage(`åŸºå‡†æµ‹è¯•å®Œæˆï¼šå¹³å‡ ${avgFps.toFixed(1)} FPS`);
                    }
                };

                requestAnimationFrame(benchmark);
            }

            reset() {
                this.params = {
                    count: 1000,
                    cohesionForce: 1.0,
                    separationForce: 1.0,
                    alignmentForce: 1.0,
                    maxSpeed: 2.0,
                    separationRadius: 25,
                    alignmentRadius: 50,
                    cohesionRadius: 100,
                    neighborRadius: 100,
                    targetForce: 0.5,
                    mode: 'flock',
                    showTrails: true,
                    showConnections: true,
                    showInfluence: false,
                    showGrid: false,
                    rainbowMode: false,
                    time: 0
                };

                this.createUnits(1000);
                this.updateSliders();
                this.updateCheckboxes();
                this.showMessage('å·²é‡ç½®ä¸ºé»˜è®¤è®¾ç½®');
            }

            updateCheckboxes() {
                document.getElementById('showTrails').checked = this.params.showTrails;
                document.getElementById('showConnections').checked = this.params.showConnections;
                document.getElementById('showInfluence').checked = this.params.showInfluence;
                document.getElementById('showGrid').checked = this.params.showGrid;
                document.getElementById('rainbowMode').checked = this.params.rainbowMode;
            }

            showMessage(text) {
                // åˆ›å»ºä¸´æ—¶æ¶ˆæ¯
                const msg = document.createElement('div');
                msg.textContent = text;
                msg.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(79, 195, 247, 0.9);
                    color: white;
                    padding: 20px 40px;
                    border-radius: 10px;
                    font-size: 18px;
                    font-weight: bold;
                    z-index: 1000;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                `;
                document.body.appendChild(msg);

                setTimeout(() => {
                    document.body.removeChild(msg);
                }, 2000);
            }

            update() {
                // æ›´æ–°æ—¶é—´
                this.params.time = Date.now();

                // æ›´æ–°æ¸¸æˆé€»è¾‘
                this.updateGame();

                // æ›´æ–°æ¸¸æˆå¯¹è±¡
                for (let obj of this.gameObjects) {
                    obj.update();
                }

                // æ›´æ–°æ‰€æœ‰å•ä½
                for (let unit of this.units) {
                    unit.update(this.units, this.params, this.canvas.width, this.canvas.height, this.targetX, this.targetY);
                }

                // æ£€æŸ¥ç¢°æ’
                this.checkCollisions();

                // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                this.updateStats();
            }

            updateStats() {
                // è®¡ç®—FPS
                this.frameCount++;
                const currentTime = performance.now();
                if (currentTime - this.lastTime >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastTime = currentTime;

                    // æ›´æ–°æ˜¾ç¤º
                    document.getElementById('unitCount').textContent = this.units.length;
                    document.getElementById('fps').textContent = this.fps;
                    document.getElementById('renderTime').textContent = this.renderTime.toFixed(1) + 'ms';

                    // ä¼°ç®—å†…å­˜ä½¿ç”¨
                    const memoryUsage = (this.units.length * 100) / 1024 / 1024; // ç²—ç•¥ä¼°ç®—
                    document.getElementById('memory').textContent = memoryUsage.toFixed(1) + 'MB';
                }
            }

            draw() {
                const startTime = performance.now();

                // æ¸…ç©ºç”»å¸ƒ
                if (this.gameState === 'menu') {
                    this.ctx.fillStyle = 'rgba(10, 10, 30, 1)';
                } else {
                    this.ctx.fillStyle = 'rgba(10, 10, 30, 0.1)';
                }
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // ç»˜åˆ¶ç½‘æ ¼
                if (this.params.showGrid) {
                    this.drawGrid();
                }

                // ç»˜åˆ¶æ¸¸æˆå¯¹è±¡
                for (let obj of this.gameObjects) {
                    obj.draw(this.ctx);
                }

                // ç»˜åˆ¶ç›®æ ‡ç‚¹
                this.drawTarget();

                // ç»˜åˆ¶è¿æ¥çº¿
                if (this.params.showConnections) {
                    this.drawConnections();
                }

                // ç»˜åˆ¶å½±å“èŒƒå›´
                if (this.params.showInfluence) {
                    this.drawInfluence();
                }

                // ç»˜åˆ¶æ‰€æœ‰å•ä½
                for (let unit of this.units) {
                    unit.draw(this.ctx, this.params);
                }

                // ç»˜åˆ¶æ¸¸æˆçŠ¶æ€
                if (this.gameState === 'menu') {
                    this.drawMenuScreen();
                } else if (this.gameState === 'paused') {
                    this.drawPausedScreen();
                } else if (this.gameState === 'gameover') {
                    this.drawGameOverScreen();
                }

                this.renderTime = performance.now() - startTime;
            }

            drawMenuScreen() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.fillStyle = '#fff';
                this.ctx.font = 'bold 48px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('é›†ä½“æ™ºæ…§', this.canvas.width / 2, this.canvas.height / 2 - 50);

                this.ctx.font = '24px Arial';
                this.ctx.fillText('ç‚¹å‡»"å¼€å§‹æ¸¸æˆ"å¼€å§‹å†’é™©', this.canvas.width / 2, this.canvas.height / 2 + 20);

                this.ctx.font = '16px Arial';
                this.ctx.fillStyle = '#aaa';
                this.ctx.fillText('ç§»åŠ¨é¼ æ ‡æ§åˆ¶ç¾¤ä½“ â€¢ Q/W/E/Rä½¿ç”¨æŠ€èƒ½', this.canvas.width / 2, this.canvas.height / 2 + 60);
            }

            drawPausedScreen() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.fillStyle = '#fff';
                this.ctx.font = 'bold 36px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('æ¸¸æˆæš‚åœ', this.canvas.width / 2, this.canvas.height / 2);
            }

            drawGameOverScreen() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.fillStyle = '#f44336';
                this.ctx.font = 'bold 48px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('æ¸¸æˆç»“æŸ', this.canvas.width / 2, this.canvas.height / 2 - 50);

                this.ctx.fillStyle = '#fff';
                this.ctx.font = '24px Arial';
                this.ctx.fillText(`æœ€ç»ˆå¾—åˆ†ï¼š${this.score}`, this.canvas.width / 2, this.canvas.height / 2 + 20);
            }

            drawGrid() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                this.ctx.lineWidth = 1;

                const gridSize = 50;
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }

                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }

            drawTarget() {
                // ç»˜åˆ¶ç›®æ ‡ç‚¹
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.beginPath();
                this.ctx.arc(this.targetX, this.targetY, 8, 0, Math.PI * 2);
                this.ctx.fill();

                // ç»˜åˆ¶è„‰å†²æ•ˆæœ
                const pulse = Math.sin(Date.now() * 0.005) * 0.5 + 0.5;
                this.ctx.strokeStyle = `rgba(255, 255, 255, ${pulse * 0.3})`;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(this.targetX, this.targetY, 20 + pulse * 10, 0, Math.PI * 2);
                this.ctx.stroke();
            }

            drawConnections() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 0.5;

                // åªç»˜åˆ¶éƒ¨åˆ†è¿æ¥ä»¥é¿å…æ€§èƒ½é—®é¢˜
                const maxConnections = Math.min(500, this.units.length * 2);
                let connections = 0;

                for (let i = 0; i < this.units.length && connections < maxConnections; i++) {
                    const unit = this.units[i];
                    for (let neighbor of unit.neighbors.slice(0, 3)) {
                        if (connections >= maxConnections) break;

                        this.ctx.beginPath();
                        this.ctx.moveTo(unit.x, unit.y);
                        this.ctx.lineTo(neighbor.boid.x, neighbor.boid.y);
                        this.ctx.stroke();
                        connections++;
                    }
                }
            }

            drawInfluence() {
                // ç»˜åˆ¶ç›®æ ‡ç‚¹çš„å½±å“èŒƒå›´
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                this.ctx.beginPath();
                this.ctx.arc(this.targetX, this.targetY, 100, 0, Math.PI * 2);
                this.ctx.fill();
            }

            gameLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        const game = new CollectiveMindGame();
    </script>
</body>
</html>